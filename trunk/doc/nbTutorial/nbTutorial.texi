\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nbTutorial.info
@include version.texi
@settitle NodeBrain Tutorial
@c %**end of header

@finalout
@paragraphindent none
@setchapternewpage odd

@copying
NodeBrain Tutorial@*
March, 2009@*
The Boeing Company,  P.O. Box 3707, Seattle, WA 98124, USA

@sp 2
@b{Release 0.7.5}

Author: Ed Trettevik <eat@@nodebrain.org>

Copyright @copyright{} 2006, 2007, 2008, 2009 The Boeing Company

@sp 1
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included in the section titled @i{GNU Free Documentation License} preceding the index at the end of this document.

@sp 1
NodeBrain(TM) is a trademark of The Boeing Company.   All other trademarks and registered trademarks referenced in this document are the trademarks of their respective owners.

@sp 2
@b{Software License}

@multitable {------------------------------} {----------------------------------------------------}
@item Copyright @copyright{} 1998-2009 @tab The Boeing Company
@item @tab Ed Trettevik <eat@@nodebrain.org>
@end multitable

NodeBrain is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public License as published by theFree Software Foundation; either version 2 of the License, or (at your option)any later version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License formore details.

You should have received a copy of the GNU General PublicLicense along with this program; if not, write to Free Software Foundation,Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@end copying

@iftex
@titlepage
@c @image{./image001,32pt,32pt,,gif}

@titlefont{NodeBrain Tutorial}
@sp 1
@tex
\vskip4pt \hrule height 3pt width \hsize
@end tex
@sp 3
@b{Release @value{VERSION}}
@page
@vskip 0pt plus 1filll
@insertcopying

@c History Preface and Document Conventions 
@page
@b{History}

@multitable {-------------} {--------------------------------------------------------------------------------------------------------}
@item 2005-10-12 @tab
Title: @i{NodeBrain  Tutorial}@*  
Author: Ed  Trettevik <eat@@nodebrain.org>@*
Publisher: The Boeing Company

@item @tab
Version 0.6.3 (not released)  
@itemize @bullet
@item Operating mode tutorial   
@end itemize

@item 2006-04-04 @tab   
Release 0.6.4
@itemize @bullet
@item Included interface examples of release 0.6.4 enhancement.
@item Included cell expression and ignorance tutorials.
@end itemize

@item 2007-01-03 @tab   
Version 0.6.6 (not released)  
@itemize @bullet
@item Minor corrections  
@end itemize

@item 2007-07-03 @tab   
Version 0.6.8 (not released)  
@itemize @bullet
@item Terminology change: "node" replaces "expert"
@end itemize

@item 2008-08-20 @tab   
Version 0.7.1 (not released)
@itemize @bullet
@item Updated with 0.7 syntax changes (see @i{NodeBrain Language Reference})
@item Included translator, servant, pipe, audit, peer, and webster node tutorials
@end itemize

@item 2009-02-05 @tab   
Release 0.7.4   
@itemize @bullet
@item Included tree, cache, syslog, and snmptrap node tutorials
@end itemize

@item 2009-03-04 @tab
Release 0.7.5
@itemize @bullet
@item Refined for PDF format
@item Several minor corrections
@end itemize

@end multitable

@page
@b{Preface}

@sp 1
This tutorial is intended for readers seeking an introduction to NodeBrain through a series of simple examples.  Other documents are available for readers looking for a more complete reference to the rule language, modules or API.

The intent of the examples in this tutorial is to illustrate individual concepts, not to provide complete working applications or show all related options.
We avoid formal syntax descriptions, thinking you are here because you want to figure it out from examples.  

Files referenced in this tutorial are included in the tutorial directory of the NodeBrain distribution.  

See www.nodebrain.org for more information and the latest update to this document.

@sp 2
@b{Documents}
@sp 1
@quotation
@i{NodeBrain Tutorial}

@i{NodeBrain User Guide}

@i{NodeBrain Language Reference}

@i{NodeBrain Module Reference}

@i{NodeBrain API Reference}
@end quotation

@sp 2
@b{Document Conventions}
@sp 1
Sample code and input/output examples are displayed in a fixed font, indented in HTML and Info, and enclosed
in a box in PDF or printed copies.
Bold text is used to bring the reader's attention to specific portions of an example.
In the following example the first and last line are associated with the host shell and the lines in between are input or output unique to NodeBrain.
The @code{define} command is highlighted, indicating it is the focus of the example.
Lines starting with "@dots{}" are a continuation of the previous line ending with "@dots{}".
This is not part of the language, just our way of breaking up single lines to fit on a printed page.
If you copy an example, you must remove the dots and combine the lines into a single line.

@example
$ nb
> @b{define myFirstRule on(a=1 and b=2) mood="happy";}
> assert mood="sad";
> show mood
mood = "sad"
> assert a=1,b=2,c=3,d="This is an example of a long single line that", @dots{}
@dots{} e="we depict on multiple lines to fit on the documnet page";
2008/06/05 12:09:08 NB000I Rule myFirstRule fired(mood="happy")
> show mood
mood = "happy"
> quit
$
@end example

@end titlepage

@end iftex

@c ----------------------------------------------------------
@c Not printed document

@ifnottex
@node Top
@top NodeBrain Tutorial @value{VERSION}

This tutorial is for NodeBrain (version @value{VERSION}, @value{UPDATED}), an open source agent
for state and event monitoring.

Copyright @copyright{} 2006, 2007, 2008, 2009 The Boeing Company

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included in the section titled @i{GNU Free Documentation License} preceding the index at the end of this document.
@end quotation

@ifnotplaintext
@b{Rule Engine Tutorials}
@end ifnotplaintext
@menu
* Invoking NodeBrain:: Interactive, batch, servant, and agent
* Cell Expressions:: Specifying rule conditions
* Ignorance:: Dealing with the unknown
* Rules:: State and event  monitoring
* Syntax Surprises:: You might have expected something different
@end menu

@ifnotplaintext
@b{Node Module Tutorials}
@end ifnotplaintext
@menu
* Tree:: A memory lookup structure
* Cache:: Monitoring repetition and variation
* Servant:: Integrating with your scripts and programs
* Translator:: Converting text to NodeBrain commands
* Audit:: Log monitoring
* Syslog:: Remote syslog monitoring
* Snmptrap:: Monitoring SNMP traps
* Pipe:: Simple command stream
* Peer:: NodeBrain to NodeBrain
* Webster:: Minimal web interface
@end menu

@ifnotplaintext
@b{References}
@end ifnotplaintext
@menu
* GNU Free Documentation License::
* Index::
@end menu
@end ifnottex

@c Set page footings
@oddfooting @thistitle @| @| @thispage
@evenfooting @thispage @| @| @thistitle

@c Table of Contents
@oddheading @| @| 
@evenheading @| @|
@contents

@c Set page headings for document
@oddheading @thischapter @| @| @value{UPDATED-MONTH}
@evenheading @value{UPDATED-MONTH} @| @| @thischapter


@node Invoking NodeBrain   
@chapter Invoking NodeBrain
@cindex invoking NodeBrain

@sp 1
This tutorial illustrates how to invoke NodeBrain and introduces the reader to modes of operation that enable NodeBrain to adapt in minor ways to the requirements of different components within a monitoring application.  Some basic concepts about the language syntax and semantics are introduced along the way.  

@menu
* Interactive Mode::
* Batch Mode::
* Servant Mode::
* Agent Mode::
@end menu

@node Interactive Mode
@section Interactive Mode

The easiest way to get started with NodeBrain is to invoke it interactively, type some commands and watch it respond.  This tutorial will walk you through some simple interactive sessions.

@menu
* Starting and Ending an Interactive Session::
* Assertions::
* On Rules::
* Shell Commands::
* Consulting Servant Scripts::
* Rule Actions::
* Action Servant Scripts::
* Rule Files::
@end menu


@node Starting and Ending an Interactive Session
@subsection Starting and Ending an Interactive Session

If you execute NodeBrain with no arguments, it starts in interactive mode and presents a prompt.  At a Unix or Linux shell command prompt you start NodeBrain by typing @code{nb}.  It looks like this.

@example
$ @b{nb}

N o d e B r a i n   0.7.4 (Dunce) 2008/11/15

Compiled Jan 28 2009 06:14:15 s390x-ibm-linux-gnu

Copyright (C) 1998-2009 The Boeing Company
GNU General Public License
----------------------------------------------------------------

nb

Date       Time     Message
---------- -------- --------------------------------------------
2009/01/28 06:14:21 NB000I NodeBrain nb[28964] myuser@@myhost
2009/01/28 06:14:21 NB000I User profile /home/myuser/.nb/user.nb loaded.
2009/01/28 06:14:21 NB000I Reading from standard input.
---------- --------

>
@end example

Since the information NodeBrain displays when starting up is not important to the topics covered in this tutorial, we will not include it in our examples.  The example above is reduced to this.

@example
$ @b{nb}
> 
@end example

At a Windows command prompt it looks like this.

@example
C:> @b{nb}
> 
@end example

For the examples in this tutorial we will use the Unix style shell command prompt.

To end an interactive session, just tell NodeBrain you want to quit.

@example
$ nb
> @b{quit}
$
@end example

You may also use Cntl-D or Cntl-C to end an interactive session.

@node Assertions
@subsection Assertions

@quotation
@i{The partisan, when he is engaged in a dispute, cares nothing about the rights of the question, but is anxious only to convince his hearers of his own assertions.} -- Plato (427 BC - 347BC), Dialogues, Phaedo
@end quotation

It is quite easy to convince NodeBrain of your own assertions.  It looks like this.

@example
$ nb
> @b{assert a=1,b=2,mood="happy";}
@end example

To verify that NodeBrain is willing to accept your assertions, ask it to show you what it now believes about a, b and mood;

@example
> @b{show a}
a = 1
> @b{show b}
b = 2
> @b{show mood}
mood = "happy"
> quit
@end example

@node On Rules
@subsection Rules

@quotation
@i{Hell, there are no rules here--we're trying to accomplish something.}
--- Thomas A. Edison (1847 - 1931)
@end quotation

If you are trying to accomplish something with NodeBrain and there are no rules, you are using the wrong tool.  NodeBrain is a rule engine, not a general purpose shell or scripting language.  There are many good shells and scripting languages to choose from, and much to be accomplished without rules --- at least not the kind of rules we are talking about here.  In a more general sense, no computing exists without rules, but the kind of rules you find in NodeBrain and similar tools are not appropriate for most computing problems.  However, they can be quite handy when applied to the right problems.

Let's start with a rule that doesn't accomplish anything.

@example
$ nb
> @b{define myFirstRule on(a=1 and b=2);}
> assert a=1;
> assert c=3;
> assert b=2;
2008/06/05 12:19:05 NB000I Rule myFirstRule fired
> assert a=0;
> assert c=1;
> assert a=1;
2008/06/05 12:19:21 NB000I Rule myFirstRule fired
> quit
$
@end example

What just happened there?  Well, we defined a rule named @file{myFirstRule} and specified a condition @code{(a=1 and b=2)} under which we want it to fire.  Each time this condition transitioned to a "true" state, the rule fired.

Let's modify this example to make it accomplish something---perhaps an assertion.  

@example
$ nb
> @b{define mySecondRule on(a=1 and b=2) mood="happy";}
> assert mood="sad";
> show mood
mood = "sad"
> assert a=1,b=2,c=3;
2008/06/05 12:20:48 NB000I Rule mySecondRule fired(mood="happy")
> show mood
mood = "happy"
> quit
$
@end example

The assertion that a=1, b=2 and c=3 changed our mood from "sad" to "happy".  Who said you can't accomplish something by following rules?

@node Shell Commands
@subsection Shell Commands

@quotation
@i{She did not talk to people as if they were strange hard shells she had to crack open to get inside. She talked as if she were already in the shell. In their very shell.}   --- Marita Bonner
@end quotation

From NodeBrain you can get into the host systems command shell by using a command prefix of @code{-}.

@example
$ nb
> @b{-date}
[17445] Started: -date
[17445| Thu Jun  512:22:34 PDT 2008
[17445] Exit(0)
> @b{-ls -al kim.nb}
[17478] Started: -ls -al kim.nb
[17478| -rw-r--r-- 1 myuser users 52 2006-01-05 11:44 kim.nb
[17478] Exit(0)
> quit
$
@end example

When you talk as if you are in someone else's shell, you need to speak their language.  Here's an example on Windows.

@example
C:> nb
> @b{-dir}
[1060] Started: -dir
[1060|  Volume in drive C has no label.
[1060|  Volume Serial Number is 0C62-77CF
[1060|
[1060|  Directory of C:\home\nodebrain\nb-0.6.4-source.msdsw\Release
[1060|
[1060| 03/28/2006  05:23 PM    <DIR>          .
[1060| 03/28/2006  05:23 PM    <DIR>          ..
[1060| 03/28/2006  04:26 PM           303,104 nb.exe
[1060| 03/28/2006  04:26 PM            10,163 nb.exp
[1060| 03/28/2006  04:26 PM            17,728 nb.lib
[1060|                3 File(s)      2,942,497 bytes
[1060|                2 Dir(s)  11,946,586,112 bytes free
[1060] Exit(0)
> quit
$
@end example

When we direct NodeBrain to execute another command to perform a task, we refer to the child process as @i{servant}.

@node Consulting Servant Scripts
@subsection Consulting Servant Scripts

@quotation
@i{CONSULT,v.i. To seek another's disapproval of a course already decided on.}  --- Ambrose Bierce (1842 - 1914), The Devil's Dictionary
@end quotation

NodeBrain is willing to accept the advice of others---even servants.  To illustrate this, let's first write a simple Perl script named processCount.pl that checks to see how many processes are running on a Unix system.

@example
#!/usr/bin/perl
chomp($processes=`ps -e|wc -l`);
print("assert processes=$processes;\n");
@end example

Now let's execute it in our Unix command shell.

@example
$ ./processCount.pl
assert processes=40;
@end example

Now we can consult this script from NodeBrain by using a prefix of "@code{-:}" instead of just "@code{-}".  This tells NodeBrain to accept the output of the shell command as input to the NodeBrain interpreter.

@example
$ nb
> @b{-:./processCount.pl}
[17537] Started: -:./processCount.pl
[17537: assert processes=40;
[17537] Exit(0) 
> show processes
processes = 40
> quit
$
@end example

@node Rule Actions
@subsection Rule Actions

@quotation
@i{You ask me why I do not write something... I think one's feelings waste themselves in words, they ought all to be distilled into actions and into actions which bring results.}
- Florence Nightingale (1820 -1910), in Cecil Woodham-Smith, Florence Nightingale, 1951
@end quotation

Any NodeBrain command can be used as a rule action by following the rule condition with a colon @code{:} and the action command.

@example 
$ nb
> define cmdRule on(a and b)@b{: show x;}
> assert x=3;
> assert a,b;
2008/06/05 12:27:41 NB000I Rule cmdRule fired
: show x;
x = 3
> quit
$
@end example

@node Action Servant Scripts
@subsection Action Servant Scripts

When the action you want to take in response to a condition is not a trivial command, you can often turn it into one by writing a script in your favorite scripting language.  We'll illustrate this in an odd way by writing a trivial Perl script and ask you to imagine that it isn't trivial. We'll call this script alarmMe.pl.

@example
alarmMe.pl
#!/usr/bin/perl
$id=shift();
$msg=shift();
$me=getpwuid($<);
system("mailx -s \"$id: $msg\" $me < note$id.txt");
@end example

Here's a session that uses a rule that invokes our alarmMe.pl script as a servant.

@example
$ nb
> define alarmRule on(a):-./alarmMe.pl 1 "Things aren't looking good"
> assert a;
2008/06/05 12:31:42 NB000I Rule alarmRule fired
: -./alarmMe.pl 1 "Things aren't looking good"
[17571] Started: -./alarmMe.pl 1 "Things aren't looking good"
[17571] Exit(0)
> quit
$
@end example

@node Rule Files
@subsection Rule Files (Scripts) 

A rule file is just a file that contains NodeBrain rules. By convention we use a @code{.nb} suffix on these files.  We can combine what we've learned in this section into a rule file named @file{roger.nb}.

@example
# roger.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes"
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes"
define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
@end example

When we specify a file as an argument to NodeBrain, it reads the file and processes the commands.

@example
$ nb roger.nb
2008/06/05 14:37:14 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2008/06/05 14:37:14 NB000I Source file "roger.nb" included. size=246
2008/06/05 14:37:14 NB000I NodeBrain nb[5393] terminating - exit code=0
$
@end example

But wait, this is a tutorial on interactive sessions.  What happened to our prompt?
Remember we said that NodeBrain assumes we want an interactive session when we don't specify any arguments?
Well, when we specify a file NodeBrain assumes we want a batch session and just processes the file and quits.

To tell NodeBrain we want an interactive session after the file is processed, we need to give it an additional @code{-} argument.

@example
$ nb roger.nb -
2009/03/16 11:32:35 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2009/03/16 11:32:35 NB000I Source file "roger.nb" included. size=243
2009/03/16 11:32:35 NB000I Argument [2] -
2009/03/16 11:32:35 NB000I Reading from standard input.
---------- --------
> @b{assert a,b=2;}
2009/03/16 11:32:48 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[3515] Started: -:./processCount.pl
[3515: assert processes=74;
2009/03/16 11:32:48 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[3519] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[3519] Exit(0)
[3515] Exit(0)
> @b{quit}
2009/03/16 11:32:52 NB000I NodeBrain nb[3514] terminating - exit code=0
@end example

@node Batch Mode
@section Batch Mode    

Except for the user prompt, everything you learned in the previous section on interactive sessions applies to batch sessions.  The rules are the same; we just no longer assume a user is typing commands.

@subsection Starting and Stopping a Batch Session

In the previous section we actually ran a batch session by accident.

@example
$ nb roger.nb
2008/06/05 14:42:37 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2008/06/05 14:42:37 NB000I Source file "roger.nb" included. size=246
2008/06/05 14:42:37 NB000I NodeBrain nb[5409] terminating - exit code=0
$
@end example

We start a batch session by giving nb at least one source file without specifying the "-" option.  A batch session ends when all source files have been processed.

Let's create a second source file with some assertions; call it abby.nb.

@example
# abby.nb
assert a=1,b=3;
assert b=2;
assert a=0;
assert a=1;
@b{@ }
@end example

Let's combine the rule file and assertions in a single batch session.

@example
@b{@ }
$ nb roger.nb abby.nb
2008/06/05 20:35:59 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2008/06/05 20:35:59 NB000I Source file "roger.nb" included. size=251
2008/06/05 20:35:59 NB000I Argument [2] abby.nb
> # abby.nb
> assert a=1,b=3;
> assert b=2;
2008/06/05 20:35:59 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7141] Started: -:./processCount.pl
[7141: assert processes=58;
2008/06/05 20:35:59 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[7145] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[7145] Exit(0)
[7141] Exit(0)
> assert a=0;
> assert a=1;
2008/06/05 20:36:00 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7152] Started: -:./processCount.pl
[7152: assertprocesses=62;
[7152] Exit(0)
2008/06/05 20:36:00 NB000I Source file "abby.nb" included. size=52
2008/06/05 20:36:00 NB000I NodeBrain nb[7140] terminating - exit code=0
$
@end example

This time our batch session generated an alarm saying "ok - under 100 processes".  Do you know why rule myProcessRule3 fired twice, but rule myProcessRule2 only fired once?  It is because the rule condition for myProcessRule3 transitioned to a true state twice, while the condition for myProcessRule2 only transitioned to a true state once.  An @code{on} rule whose condition is true will not fire when a new assertion causes it to remain true. 

@subsection Piping Commands to a Batch Session

If you give NodeBrain an equal symbol @code{=} as an argument, it processes stdin like any other file.  Let's do the same thing we did in the previous example using a pipe to stdin.

@example
$ cat roger.nb abby.nb | nb =
@end example

We can combine the @code{=} argument with other source file arguments.

@example
$ cat abby.nb | nb roger.nb =
@end example

Files are processed in the order of arguments.  If we change the argument order the assertions are made before we define the rules, so we don't get the same results.

@example
$ cat abby.nb | nb = roger.nb
@end example

This is like specifying the following command.

@example
$ nb abby.nb roger.nb
@end example

Ok, so we now know how to pipe commands into NodeBrain. Maybe it would be handy to use a script as the source of assertions.  Here's a script called randy.pl that will generate some pseudo random values for a and b.

@example
randy.pl
#!/usr/bin/perl
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print("assert a=$r;\n");@}
  else@{print("assert b=$r;\n");@}
  @}
@end example

We can use this script as the source of our assertions by piping the output of the script to NodeBrain.

@example
$ ./randy.pl | nb roger.nb =
2008/06/05 20:54:23 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2008/06/05 20:54:23 NB000I Source file "roger.nb" included. size=251
2008/06/05 20:54:23 NB000I Argument [2] =
2008/06/05 20:54:23 NB000I Reading from standard input.
---------- --------
| assert a=3;
| assert a=1;
| assert a=1;
| assert b=0;
| assert b=2;
2008/06/05 20:54:23 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7251] Started: -:./processCount.pl
[7251: assert processes=58;
2008/06/05 20:54:23 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[7255] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[7255] Exit(0)
[7251] Exit(0)
| assert b=0;
| assert b=2;
2008/06/05 20:54:24 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7262] Started: -:./processCount.pl
[7262: assert processes=62;
[7262] Exit(0)
| assert a=1;
| assert b=0;
2008/06/05 20:54:25 NB000I NodeBrain nb[7250] terminating - exit code=0
$
@end example

We can also pipe from within a script.  In randal.pl we open a pipe to NodeBrain and write to the pipe.

@example
randal.pl
#!/usr/bin/perl
@b{open(NB,"|nb roger.nb =")||die;}
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print(@b{NB} "assert a=$r;\n");@}
  else@{print(@b{NB} "assert b=$r;\n");@}
  @}
@b{close(NB);}
@end example

The result is the same.

@example
$ ./randal.pl
2008/06/05 21:02:43 NB000I Argument [1] roger.nb
> # roger.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
2008/06/05 21:02:43 NB000I Source file "roger.nb" included. size=251
2008/06/05 21:02:43 NB000I Argument [2] =
2008/06/05 21:02:43 NB000I Reading from standard input.
---------- --------
| assert b=0;
| assert b=0;
| assert a=1;
| assert b=2;
2008/06/05 21:02:43 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7376] Started: -:./processCount.pl
[7376: assert processes=59;
2008/06/05 21:02:44 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[7380] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[7380] Exit(0)
[7376] Exit(0)
| assert a=3;
| assert b=2;
| assert b=0;
| assert a=3;
| assert a=1;
2008/06/05 21:02:44 NB000I NodeBrain nb[7375] terminating - exit code=0
$
@end example

So, any way you can establish a pipe to NodeBrain is fine, just remember to tell NodeBrain to read stdin by specifying @code{=} as a file argument.

@node Servant Mode
@section Servant Mode

@quotation
@i{If thou are a master, be sometimes blind; if a servant, sometimes deaf.}
        -- Thomas Fuller (1608 -1661)
@end quotation

When NodeBrain reads commands from stdin in batch mode, it uses blocking I/O.
This means it does nothing while waiting for the next command from the master.  If the master is mute, NodeBrain is an idle slave.  In servant mode, NodeBrain reads stdin using non-blocking I/O and is free to perform other duties while waiting for the next command from the master.

@subsection Scheduling Rules

Let's first learn a simple way to give NodeBrain something else to do while waiting for commands.  Here's a rule file like roger.nb that includes a scheduling rule.  We'll call it jeeves.nb.

@example
# jeeves.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
@b{define mySchedulingRule on(~(3s)) a=0;}
@end example

The rule condition ~(3s) specifies that the rule should fire every 3 seconds.  When the mySchedulingRule fires, it asserts that a=0.  If NodeBrain is waiting on input from stdin, it can not trigger this rule as specified.  So we're going to have to change the way we run NodeBrain.

@subsection Servant Option

Here's a script called bertie.pl that uses the @code{-s} option to put NodeBrain in servant mode once all the input files specified as arguments have been processed.

@example
bertie.pl
#!/usr/bin/perl
use FileHandle;
open(NB,"|nb jeeves.nb @b{-s}")||die;  # use servant option
NB->autoflush(1);       # force output to nb as soon as we send a command
for($i=1;$i<10;$i++)@{
  $r=int(rand()*4);
  if($r%2)@{print(NB "assert a=$r;\n");@}
  else@{print(NB "assert b=$r;\n");@}
  @b{sleep(5);}             # pretend like we are busy working on something
  @}
@b{print(NB "stop\n");}    # stop the servant mode nb
close(NB);
@end example

You can see from the output below that the activity scheduled by mySchedulingRule is taking place between commands sent by bertie.pl.   

@example
$ ./bertie.pl
2008/06/05 21:31:00 NB000I Argument [1] jeeves.nb
> # jeeves.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> define myProcessRule3 on(a=1 and b=2):-:./processCount.pl
> define mySchedulingRule on(~(3s)) a=0;
2008/06/05 21:31:00 NB000I Source file "jeeves.nb" included. size=283
2008/06/05 21:31:00 NB000I Argument [2] -s
2008/06/05 21:31:00 NB000T Servant mode selected
---------- ----------------------------------------------------
> assert a=3;
2008/06/05 21:31:03 NB000I Rule mySchedulingRule fired (a=0)
> assert b=0;
2008/06/05 21:31:06 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:09 NB000I Rule mySchedulingRule fired (a=0)
> assert a=3;
2008/06/05 21:31:12 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:15 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:18 NB000I Rule mySchedulingRule fired (a=0)
> assert b=0;
2008/06/05 21:31:21 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:24 NB000I Rule mySchedulingRule fired (a=0)
> assert a=3;
2008/06/05 21:31:27 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:30 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:33 NB000I Rule mySchedulingRule fired (a=0)
> assert b=2;
2008/06/05 21:31:36 NB000I Rule mySchedulingRule fired (a=0)
2008/06/05 21:31:39 NB000I Rule mySchedulingRule fired (a=0)
> assert a=1;
2008/06/05 21:31:40 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[7537] Started: -:./processCount.pl
[7537: assert processes=59;
2008/06/05 21:31:40 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[7541] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[7541] Exit(0)
[7537] Exit(0)
2008/06/05 21:31:43 NB000I Rule mySchedulingRulefired (a=0)
2008/06/05 21:31:45 NB000I Rule mySchedulingRulefired (a=0)
> stop
2008/06/05 21:31:45 NB000I NodeBrain nb[7536] terminating - exit code=0
$
@end example

@node Agent Mode
@section Agent Mode

Monitoring applications normally require a program that runs constantly and mostly without user control, but acts on the user's behalf. These qualities of persistence, relative autonomy, and user directed goals are characteristic of a software agent.  We know these programs as daemons on UNIX or Linux, and services on Windows.

Let's modify our rules from the previous example so we execute our process counting script every minute.   

@example
# maxwell.nb
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
define myProcessRule3 on(~(m)):-:./processCount.pl
@end example

Now we'll execute it.

@example 
$ nb maxwell.nb
2008/06/05 21:45:53 NB000I Argument [1] maxwell.nb
> # maxwell.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:45:53 NB000I Source file "maxwell.nb" included. size=273
2008/06/05 21:45:53 NB000I NodeBrain nb[7618] terminating - exit code=0
$
@end example

But wait, that’s not right.  The program just ended after loading the rules.  We need a way to tell it to run as a daemon.  We’ll try the daemon option, “-d”.
 
@example
$ nb –d maxwell.nb
2008/06/05 21:47:28 NB000I Argument [1] -d
2008/06/05 21:47:28 NB000I Argument [2] maxwell.nb
> # maxwell.nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:47:28 NB000I Source file "maxwell.nb" included. size=273
2008/06/05 21:47:28 NB000I NodeBrain nb[@b{7621},7060]daemonizing
$
@end example

Ok, that's better, it daemonized.  That just means it disconnected from the terminal and is running in the background with no stdin or stdout.  It actually forks a new process to run as the daemon and then ends.

@example
$ ps -ef | grep nb
myuser   @b{7622}     1  0 21:47 ?       00:00:00 nb -d maxwell.nb
@end example

Well, we have an agent running now, but we don't have anyway to see what it is doing.  To give us better visibility we need to instruct NodeBrain to write to a log file.  While we're at it, let's make this an executable script by adding a she-bang line.  Guess we should stop the running agent also.

@example
$ kill 7622
@end example

Here's our enhanced agent we'll call james.nb.
 
@example
#!/usr/local/bin/nb -d
# james.nb
set log="james.log";
define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
# check process count every minute
define myProcessRule3 on(~(m)):-:./processCount.pl
@end example

If we want to execute it we need to set the file permissions.

@example
$chmod 755 james.nb
@end example

Now let's start it.

@example
$ ./james.nb
2008/06/05 21:55:31 NB000I Argument [1] -d
2008/06/05 21:55:31 NB000I Argument [2] ./james.nb
> #!/usr/local/bin/nb -d
> # james.nb
> set log="james.log";
2008/06/05 21:55:31 NB000I NodeBrain nb will log to james.log
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
> define myProcessRule2 on(processes<100):-./alarmMe.pl 2 "ok - under 100 processes."
> # check process count every minute
> define myProcessRule3 on(~(m)):-:./processCount.pl
2008/06/05 21:55:31 NB000I Source file "./james.nb" included. size=370
2008/06/05 21:55:31 NB000I NodeBrain nb[7688,7060] daemonizing
$
@end example

Now we can see what our agent is doing by tailing the log file.  Wait a minute, it isn't doing much.  Yes, wait another minute.  

@example
$ tail james.log
2009/01/28 09:04:26 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5619] Started: -:./processCount.pl
[5619: assert processes=75;
2009/01/28 09:04:26 NB000I Rule myProcessRule2 fired
: -./alarmMe.pl 2 "ok - under 100 processes."
[5623] Started: -./alarmMe.pl 2 "ok - under 100 processes."
[5623] Exit(0)
[5619] Exit(0)
2009/01/28 09:05:00 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5648] Started: -:./processCount.pl
[5648: assert processes=78;
[5648] Exit(0)
2009/01/28 09:06:00 NB000I Rule myProcessRule3 fired
: -:./processCount.pl
[5659] Started: -:./processCount.pl
[5659: assert processes=78;
[5659] Exit(0)
@end example

The log tells us the scheduled process is running and there are 78 active processes on this system.  If the count goes over 200 we will be notified by rule myProcessRule1 via the alarmMe.pl script.

That's it --- we have a working agent.  But clearly this example was not designed to convince you that NodeBrain should be used when the application is this simple.  This entire problem could be solved with one simple script written in your favorite scripting language.  NodeBrain is appropriate for situations where there is a benefit to separating declarative rules from procedural logic in a modular fashion.  It may take experimentation with more complex and evolving agent requirements to appreciate when it is appropriate.

@node Cell Expressions
@chapter Cell Expressions
@cindex cell expressions

@quotation
@i{I like nonsense; it wakes up the brain cells.}
   -- Dr. Seuss (1904 -1991)
@end quotation

What could be more nonsensical than a program called NodeBrain?  And of course, if we claim this program is a brain, there must have brain cells and a way to wake them up.  So here goes.

You can think of a cell as a structure capable of storing a value and optionally a formula for computing a value.  You may be familiar with this notion if you use a spreadsheet program.  A NodeBrain cell is vary similar to a spreadsheet cell, but without the tabular model.  There is no physical relationship between NodeBrain cells; no notions like "two to the left" or "one cell up".  NodeBrain cells are referenced only by their formula, which we call a cell expression.

Cell expressions are allowed in various places within the command syntax.
We can't tell you where exactly because we promised not to get BNF on you here, but we can say cell definitions, assertions, and rule conditions are the primary places where cell expressions are used.

@menu
* Numbers and Strings::
* Arithmetic::
* Logic::
* Time Conditions::
* Node Conditions::
* Complex Expressions::
@end menu

@node Numbers and Strings
@section Numbers and Strings

The simplest cell expressions identify a literal number or string.  Here we define a cell @code{a} with the expression @code{5}, and a cell @code{b} with the expression @code{"abc"}.

@example
$ nb
> define a cell 5;
> define b cell "abc";
> show a
a = 5
> show b
b = "abc"
> @ 
@end example

@node Arithmetic
@section Arithmetic

We can do simple arithmetic in a cell expression.

@example
$ nb
> define a cell 5+4;
> define b cell a+3;
> show a
a = ! == (5+4)
> show b
b = ! == (a+3)
> @ 
@end example

Wait, this must not be what Dr. Seuss meant by nonsense because these brain cells don't seem to be awake!  NodeBrain accepted our expression @code{5+4} but didn't compute @code{9}.  This is because NodeBrain is lazy. Nobody cares what the value of @code{a} or @code{b} is, so NodeBrain doesn't bother to compute them.
We need more nonsense to wake these brain cells up.
Let's try adding a rule that depends on the value of @code{b}.

@example
> define rule1 on(b<20);
> show a
a = 9 == (5+4)
> show b
b = 12 == (a+3)
@end example

When we added the rule referencing @code{b}, NodeBrain was motivated to compute the value of @code{a+3}.  To get the value of @code{a}, it computes the value of @code{5+4}.

The symbol @code{==} can be read as "is defined as".  The response to @code{show b} above can be read as "@code{b} is @code{12} and is defined as @code{a+3}."

Just for fun, let's see what happens when we assert new cell expressions for @code{a}.

@example
> assert a=19;
> show a
a = 19
> show b
b = 22 == (a+3)
@b{> assert a=1;}
@b{2008/06/05 22:04:51 NB000I Rule rule1 fired}
> show b
b = 4 == (a+3)
> assert a=5*15/7+2;
> show a
a = 12.71428571
> @ 
@end example

Although we are on the topic of arithmetic, it is perhaps less interesting that NodeBrain does arithmetic than when it does it.
When we asserted that @code{a=1}, NodeBrain recomputed @code{b} and got @code{4}.  It then recomputed @code{b<20} which transitioned from false to true and rule1 fired.

@node Logic
@section Logic

@quotation
@i{Logic is like the sword -- those who appeal to it shall perish by it.}
--  Samuel Butler (1835 - 1902)
@end quotation

One can appeal to logic in cell expressions, much as we do in other programming languages.  Some familiar operators are illustrated here.

@example
> assert a=1,b=2,c=3,d=3;
> define x cell a>b;
> define rule2 on(a=b or b=c or c>25);
> define rule3 on(a=21 and (b>5 or c<2));
> define rule4 on(x and not a<5.73);
> define rule5 on(a=b and c=d);
@end example

Relational operators (@code{> , < , <> , =, >=, <=}) have precedence over Boolean operators (@code{and}, @code{or}, @code{not}).  Use parentheses to force the order of precedence when you don't want the default or don't know the default.  

As we demonstrated with arithmetic expressions, NodeBrain evaluates logical expressions when there are assertions that change the value of operands.
For example, consider the following expression used by rule5.

@example
a=b and c=d
@end example

If we assert that @code{a=3}, the interpreter has to recomputed @code{a=b}, but doesn't recompute the larger expression @code{a=b and c=d}.  Since @code{c} and @code{d} didn't change, the value of @code{c=d} has not changed, and since @code{a=b} remains false, the value of the larger expression is known to be unchanged without further computation.  

There is only one cell for computing any given expression.
No matter how may rule conditions reference @code{a=b}, there is only one @code{a=b} cell, as there is only one @code{a} cell and one @code{b} cell.
Every cell knows which cells reference it.
In this example both @code{a} and @code{b} know that @code{a=b} depends on them.
If @code{a} changes, it reports a change to @code{a=b}.
If @code{b} changes, it does the same.
If @code{a} changes, @code{b} changes, or both @code{a} and @code{b} change in the same assertion, @code{a=b} is recomputed once.
If @code{a=b} changes, expressions that reference it are recomputed.

How do you think the interpreter would respond to the following assertion?

@example
assert a=21,b=21.
@end example

Because either of @code{a} or @code{b} has changed (in this case both), the interpreter must evaluate @code{a=b} again.
Since the value is still true, no further computation is required.

@node Time Conditions
@section Time Conditions

@quotation
@i{I must govern the clock, not be governed by it.}
    --  Golda Meir (1898 - 1978)
@end quotation

NodeBrain is happy to be governed by the clock.
It has an extensive algebra for expressing schedules we call time conditions.
A time condition is a function of time that is true or false at any given second.  

In the spirit of this tutorial, we will be deliberately incomplete here and just try to give you a sense of it.
The author is somewhat proud of this feature, so conscious restraint is required, but entirely appropriate.  (If you need a cure for insomnia, read about time conditions in the @i{NodeBrain Language Reference}.)

We'll just jump into it with a few examples.  We have a script called @file{schedule.nb} with rules whose names describe their time condition. Let's start it in interactive mode.

@example
$ nb schedule.nb -
2008/06/06 06:38:14 NB000I Argument [1] schedule.nb
> define FourOClockHour on(~(h(4)));
> define MondayWednesayAndFriday on(~(mo,we,fr));
2008/06/06 06:38:14 NB000I Rule MondayWednesayAndFriday fired
> define Four2FiveMonWedFri on(~(h(4).(mo,we,fr)));
> define January9 on(~(jan(9)));
> define WeekOfJanuary15 on(~(w.jan(15)));
> define ThursdayOfWeekOfJanuary15 on(~(th.w.jan(15)));
> define LastFridayInJanuary on(~(fr[-1]jan));
> define TuesdayOfWeekOfLastFridayInJanuary on(~(tu.w.fr[-1]jan));
2008/06/06 06:38:14 NB000I Source file "schedule.nb" included. size=371
2008/06/06 06:38:14 NB000I Argument [2] -
2008/06/06 06:38:14 NB000I Reading from standard input.
---------- --------
>
@end example

To see the next event for each schedule we use the show command with a @code{/c} (clock) option.
We issued this command at 6:41 on Friday June 6, 2008.  The @code{h(4)} condition will transition to true at 04:00, and then back to false at 05:00.  The @code{(mo,we,fr)} condition will transition to true at 00:00 Monday the 9th.  See if you can make sense out of the rest of the conditions in this list, given the hint that weeks start at 00:00 Sunday. Match the conditions to the name of the corresponding rule above if you need help.    

@example
> show /c
~ 2008/06/06 06:41:17 Clock
~ 2008/06/07 00:00:00 ~(mo,we,fr)
                      on(~(mo,we,fr));
~ 2008/06/07 04:00:00 ~(h(4))
                      on(~(h(4)));
~ 2008/06/09 04:00:00 ~(h(4).(mo,we,fr))
                      on(~(h(4).(mo,we,fr)));
~ 2009/01/09 00:00:00 ~(jan(9))
                      on(~(jan(9)));
~ 2009/01/11 00:00:00 ~(w.jan(15))
                      on(~(w.jan(15)));
~ 2009/01/15 00:00:00 ~(th.w.jan(15))
                      on(~(th.w.jan(15)));
~ 2009/01/27 00:00:00 ~(tu.w.fr[-1]jan)
                      on(~(tu.w.fr[-1]jan));
~ 2009/01/30 00:00:00 ~(fr[-1]jan)
                      on(~(fr[-1]jan));
@end example

A forecast command is used to see when a time condition will transition to true (left column) and false (right column).

@example
> @b{forecast ~(mo,we,fr)}
mo,we,fr schedule ~0-0 interval=0,duration=0)
fr 2008/06/06 00:00:00 1212735600 - sa 2008/06/0700:00:00 1212822000
mo 2008/06/09 00:00:00 1212994800 - tu 2008/06/1000:00:00 1213081200
we 2008/06/11 00:00:00 1213167600 - th 2008/06/1200:00:00 1213254000
fr 2008/06/13 00:00:00 1213340400 - sa 2008/06/1400:00:00 1213426800
mo 2008/06/16 00:00:00 1213599600 - tu 2008/06/1700:00:00 1213686000
we 2008/06/18 00:00:00 1213772400 - th 2008/06/1900:00:00 1213858800
> @b{forecast ~(h(4));}
h(4) schedule ~0-0 interval=0,duration=0)
sa 2008/06/07 04:00:00 1212836400 - sa 2008/06/0705:00:00 1212840000
su 2008/06/08 04:00:00 1212922800 - su 2008/06/0805:00:00 1212926400
mo 2008/06/09 04:00:00 1213009200 - mo 2008/06/0905:00:00 1213012800
tu 2008/06/10 04:00:00 1213095600 - tu 2008/06/1005:00:00 1213099200
we 2008/06/11 04:00:00 1213182000 - we 2008/06/1105:00:00 1213185600
th 2008/06/12 04:00:00 1213268400 - th 2008/06/1205:00:00 1213272000
@end example

The fundamental concepts to grasp here are that time conditions have

@enumerate
@item
identifiers like @code{mo} for Monday, @code{h} for hour, @code{jan} for January, and @code{w} for week that define a set of time intervals, and
@item
operators @code{,} , @code{.} , @code{(n)}, and @code{[n]} that operate on time interval sets to produce new sets.
@end enumerate

The operators are based on formal concepts like intersection, union, selection, rejection, inverse, etc.        

@node Node Conditions
@section Node Conditions 

@quotation
@i{An expert knows all the answers -- if you ask the right questions.}
  --  Unknown
@end quotation

A NodeBrain node is an expert, with a set of knowledge and associated skill.  The skill is provided by a node module (plug-in) that extends NodeBrain functionality.  Since NodeBrain is not a general purpose scripting language, there are many things that are simply inappropriate to attempt without help from a node module.  It is the combination of skill and knowledge that makes a node an expert.  Of course we need to know how to ask the right questions.

Node modules can be developed to perform any function imaginable, but within the context of a cell expression they only provide us with the value of node conditions.  These are expressions that look like a function call.  In rule @code{r1} below, @code{sally(x)} is a node condition and @code{sally} is a node with the skills provided by the tree module.

@example
$ nb sally.nb
2008/06/06 07:05:49 NB000I Argument [1] sally.nb
> # sally.nb
> define sally node tree;
> assert sally("abc"),sally("def",5)=2;
> show sally
sally = ! == node tree
  "def"
    5=2
  "abc"=1
> define r1 on(sally(x));
> assert x="abc";
2008/06/06 07:05:49 NB000I Rule r1 fired
@end example

Do you see why rule @code{r1} fired when we asserted that @code{x="abc"}? It is because @code{sally("abc")} was asserted to be true, so @code{sally(x)} is true when @code{x="abc"}.  What a node module does with assertions and how it computes the value of node conditions is entirely up to it.  In this case, the @code{tree} node module keeps track of assertions and returns a value for conditions by doing a lookup.  When the value of @code{x} changes, the interpreter reports a change to the node module and it computes a new value for the cell.
When the cell value changes, it reports a change to the referencing cells, in this case rule r1, which fired.

@node Complex Expressions
@section Complex Expressions

@quotation
@i{A complex system that works is invariably found to have evolved from a simple system that works.}
    -- John Gaule
@end quotation

Every type of cell expression introduced in this tutorial can be combined into complex expressions as illustrated by rule @code{complex} below.

@example
$ nb complex.nb
2008/06/06 07:14:28 NB000I Argument [1] complex.nb
> # complex.nb
> define sally node tree;
> assert sally("abc"),sally("def",5)=2;
> define complex on(sally(x,y)=a+b and y<7 and ~(fr));
> assert y=5;
> assert a,b;
> assert x="def";
2008/06/06 07:14:28 NB000I Rule complex fired
@end example

If the complex rule doesn't fire when you run @code{complex.nb}, perhaps you are not running it on a Friday.
If you try it on a Friday, it will fire because @code{y<7} is true and @code{sally(x,y)=a+b} is true.  
The fact that the last expression is true may not be so obvious, so let's break it down.  The command @code{assert a,b;}
sets @code{a} and @code{b} to 1 (true).  That means the expression @code{a+b} is 2.  Since @code{x} is "def" and @code{y} is 5, the expression @code{sally(x,y)=a+b} is @code{sally("def",5)=2}, which we assert to be true.

@node Ignorance
@chapter Ignorance
@cindex unknown value
@cindex true value
@cindex false value
@cindex special value, unknown
@cindex special value, true
@cindex special value, false

@quotation
@i{Ignorance more frequently begets confidence than does knowledge.}
     --  Charles Darwin
@end quotation

This tutorial is about ignorance; when NodeBrain is aware of it and how it is handled.  It is perhaps obvious, but important to remember, that NodeBrain assumes that whatever is asserted is the truth.  It makes no attempt to independently verify assertions, or check to see if assertions should have been made that were not.  So what NodeBrain thinks it knows may not be the truth.  In this respect, NodeBrain is unaware of its ignorance and blissfully acts with great confidence.  No different than most of us.

However, within NodeBrain's own version of reality, it can be aware of a form of ignorance.  The notion here is that something can be known to be unknown, a possibility often dismissed by people rushing to judgment.
How NodeBrain deals with that condition is the topic of this tutorial.

@menu
* True False Unknown::
* Closed World Assumption::
* Reactive Mode::
* Query Mode::
@end menu

@node True False Unknown
@section True, False, and Unknown

@quotation
@i{Something unknown is doing we don't know what.}
    -- Sir Arthur Eddington (1882 - 1944)
@end quotation

The NodeBrain interpreter recognizes three logical states: true, false, and unknown.  These states are represented as follows.

@quotation
@multitable {-------------} {-----------------------------------------------------------------------}
@item @b{Value} @tab @b{Representation}
@item Unknown @tab ?
@item False   @tab 0
@item True    @tab 1 or anything else (e.g. 5.2,-7, "abc", "")
@end multitable
@end quotation

We can test for these states by using the @code{=} relational operator or a prefix operator. The @code{!} prefix operator means "not" and the @code{?} prefix operator means "is unknown".
 
@example
> define r1 on(a=1 and b=0 and c=? and x and !y and ?z);
@end example

Values can be asserted similarly.

@example
$ nb
> assert a=1,b=0,c=?,x,!y,?z;
> show -t
@@ =! == node
z =?
y =0
x =1
c =?
b =0
a =1
> @ 
@end example

Although anything other than @code{?} or @code{0} is interpreted as true, logical operators often return a value of @code{1} to represent a true state. Below we see that the value of @code{a<b} is @code{1}.

@example
> assert a=5,b=7;
> define r1 on(a<b);
> show (a<b)
()= @b{1} == (@b{a<b})
@end example

Here's the important thing to understand.  Logical operators accept the unknown value as an operand and return the unknown value under specific conditions.  Logic tables for @code{A and B} and @code{A or B} are shown below. Notice that in some cases we know the result without knowing both operands.

@quotation
@multitable {---} {---} {------} {------}
@item   A @tab B @tab A&B @tab A|B 
@item   0 @tab 0 @tab  0  @tab  0
@item   0 @tab 1 @tab  0  @tab  1
@item   0 @tab ? @tab  0  @tab  ?
@item   1 @tab 0 @tab  0  @tab  1
@item   1 @tab 1 @tab  1  @tab  1
@item   1 @tab ? @tab  ?  @tab  1
@item   ? @tab 0 @tab  0  @tab  ?
@item   ? @tab 1 @tab  ?  @tab  1
@item   ? @tab ? @tab  ?  @tab  ?
@end multitable
@end quotation

The ? prefix operator enables us to test for an unknown condition and act upon it.

@example
$ nb
> define x cell a+b;
> define r1 on(?x);
> assert a=7,b=12;
> show -t
@@ =! == node
r1= ! == on(?x);
x =19 == (a+b)
b =12
a =7
> assert ?b;
2008/06/0607:41:34 NB000I Rule r1 fired
> 
@end example

Let's pause to make sure we all know what just happened here. The condition ?x is true when x is unknown.  This was true when we first defined r1 because x is @i{a}+@i{b} and both @i{a} and @i{b} are unknown at that time.  Hey, the arithmetic operators understand the unknown value also.  When we asserted that a=7 and b=12, x was known to be 19 and ?x was false.  Then we assert ?b, making a+b unknown, making x unknown, making ?x true and r1 fired.
 
@node Closed World Assumption
@section Closed World Assumption

Some systems use a closed world assumption, where anything not known to be true is assumed to be false.  As we illustrated in the previous section, NodeBrain does not generally make this assumption.  Instead it allows the unknown state to propagate through the evaluation of cell expression.

However, node modules are allowed to handle the unknown state using either the closed world assumption or three-state logic.  This means you must be aware of how each node module handles the unknown state when coding rules.

We'll illustrate using two nodes, one with the @code{tree} skill and one with the @code{cache} skill.  The tree module uses three-state logic and the cache module uses the closed world assumption.

@example
$ nb closedWorld.nb
2008/06/0607:44:05 NB000I Argument [1] closedWorld.nb
> define myTree expert tree;
> define myCache expert cache:(soup);
> define rMyTreeHasSoup on(myTree(soup));
> define rMyCacheHasSoup on(myCache(soup));
> define rMyTreeHasNotSoup on(!myTree(soup));
> define rMyCacheHasNotSoup on(!myCache(soup));
> define rMyTreeKnowsNotSoup on(?myTree(soup));
> define rMyCacheKnowsNotSoup on(?myCache(soup));
> assert myTree("Chicken"),myCache("Chicken");
> assert soup="Tomato"; 
> assert soup="Chicken";
2008/06/0607:44:05 NB000I Rule rMyCacheHasSoup fired
2008/06/0607:44:05 NB000I Rule rMyTreeHasSoup fired
> assert ?myTree("Chicken"),?myCache("Chicken");
2008/06/0607:44:05 NB000I Rule rMyTreeKnowsNotSoup fired
2008/06/0607:44:05 NB000I Rule rMyCacheHasNotSoup fired
> assert !myTree("Chicken"),!myCache("Chicken");
2008/06/0607:44:05 NB000I Rule rMyTreeHasNotSoup fired
2008/06/0607:44:05 NB000I Source file "closedWorld.nb" included. size=514
2008/06/0607:44:05 NB000I NodeBrain nb[13980] terminating - exit code=0
$
@end example

This may just be a blur, so let's take the assertions one at a time.  Initially @code{soup} is unknown, @code{myTree(soup)} is unknown, and @code{myCache(soup)} is false.
The reason @code{myCache(soup)} is false is because the cache skill uses the closed world assumption; what is not known to be true is false. 
When we assert @code{"Chicken"} to both the tree and the cache there is no change to the value of @code{myTree(soup)} and @code{myCache(soup)}.
When we assert that @code{soup="Tomato"} there is still no change.  A value of @code{"Tomato"} is not known to the tree or cache, in the same way an unknown soup is not known. 

Next we assert that @code{soup="Chicken"}.  Both @code{myTree(soup)} and @code{myCache(soup)} transition to true and the corresponding rules @code{rMyCacheHasSoup} and @code{rMyTreeHasSoup} fire.

This is followed by an assertion that @code{myTree("Chicken")} and @code{myCache("Chicken")} are unknown.  Because the cache skill uses the closed world assumption, this is the same as asserting that @code{myCache("Chicken")} is false.  Consequently, @code{rMyCacheHasNotSoup} fires while @code{myTreeKnowsNotSoup} fires.

Finally we assert @code{myTree("Chicken")} and @code{myCache("Chicken")} to be false.  This causes the rule @code{rMyTreeHasNotSoup} to fire.
There is no change to @code{myCache("Chicken")}, so no cache related rule fires.

The difference between the tree and cache skills is that we must assert @code{myTree(soup)} to be false before @code{myTree(soup)} evaluates to false, while @code{myCache(soup)} is false simply because we haven't asserted it to be true.
Asserting either @code{!myCache("Chicken")} or @code{?myCache("Chicken")} removes knowledge of "Chicken" from the cache.
Only an assertion of @code{?myTree("Chicken")} removes knowledge of "Chicken" from the tree.
Asserting @code{!myTree("Chicken")} asserts a value of false to the "Chicken" entry in the tree.

@node Reactive Mode
@section Reactive Mode

In all the previous examples in this tutorial the interpreter has been operating in reactive mode when processing rules.  In this mode, the interpreter waits for assertions and responds appropriately.  It makes no effort to convert unknown values into known values.  Consider the following example.

@example
$ nb
> define myProcessRule1 on(processes>200):-./alarmMe.pl 1 "dang - more than 200 processes."
>
@end example

The interpreter knows the value of processes is unknown and it does nothing to find out.  This is reasonable because we haven't asked it to and we haven't told it how.  These are possibilities we cover in the next section.

@node Query Mode
@section Query Mode

There is an interpreter mode we call @i{query} mode, in which NodeBrain attempts to solve for unknown values as required to obtain a known value for rule conditions.  This mode approximates what your doctor does when you go in with a medical problem, or your car mechanic does when you take your car in with a mechanical problem.
They ask questions of you, and they ask questions of themselves which they try to answer by running tests.  They attempt to diagnose your problem by applying rules and seeking values for parameters that are initially unknown.  They only ask the questions and run the tests that are necessary to arrive at a conclusion.
This helps to avoid running unnecessary expensive tests.

If we tell NodeBrain how to query for unknown values and ask it to solve for rule conditions that have an unknown value, it can diagnose or investigate with similar efficiency.

@subsection Query Rule Files

A query rule file is simply a rule file designed to be processed in query mode.  Here's a file named @file{illness.nb} that is a trivial (and not useful) query rule file.

@example
# File: tutorial/Ignorance/illness.nb
define CommonCold on(cough and soreThroat);
define Flu on(fever and achy and upsetStomach);
@end example

As you can see, these query rules have the same syntax as reactive rules.   The difference is not in the rules, but in how we use them.  

@subsection Interactive Query Mode

Let's invoke this script in interactive mode and issue a @code{query} command. 

@example
$ @b{nb illness.nb -}
> # File: tutorial/Ignorance/illness.nb
> define CommonCold on(cough and soreThroat);
> define Flu on(fever and achy and upsetStomach);
2008/06/10 15:51:44 NB000I Source file "illness.nb" included. size=111
2008/06/10 15:51:44 NB000I Argument [2] -
2008/06/10 15:51:44 NB000I Reading from standard input.
---------- --------
> @b{query}
 
  (fever&(achy&upsetStomach))
 
Enter cell fever==@b{0}
 
  (cough&soreThroat)
 
Enter cell cough==@b{1}

  (cough&soreThroat)
 
Enter cell soreThroat==@b{1}
2008/06/10 15:52:11 NB000I @b{Rule CommonCold fired}
> @ 
@end example

Since we are running in interactive mode and have not provided any alternate methods for NodeBrain to solve for unknown values, the interpreter prompts the user to resolve unknown values.  If you study the rule file you will find 5 unknown terms in the two rule conditions: cough, soreThroat, fever, achy, and upsetStomach.  However, the interpreter only prompted the user for values of three of these terms.  This is because requesting values for the other two terms would not have changed the result.  Since fever=0, the @code{flu} condition is false for any value of the other two terms in the condition.

Our response to each query may be any valid cell expression.  This means we must enclose strings in quotes, and have the option of introducing new terms for which the interpreter does not have a value.  When new terms are introduced, the interpreter attempts to resolve them as necessary.  If we respond with @code{5 or soreEye}, the interpreter will not attempt to solve for soreEye because it knows the expression is true without knowledge of soreEye.

@subsection Batch Query Mode

In most applications of NodeBrain we are attempting to automate decisions, so we want to query software to resolve unknowns where possible.
Here's a script called @file{illnessConsult.pl} that simulates the running of potentially complex tests to arrive at the same answers we provided interactively above.  There would be no point in doing something this simple for real, and no point in doing something more complicated in a tutorial.  You can imagine a much more complicated problem.  

@example
#!/usr/bin/perl
# File: tutorial/Ignorance/illnessConsult.pl
$state@{"cough"@}=1;
$state@{"soreThroat"@}=1;
$state@{"fever"@}=0;
$state@{"achy"@}=1;
$state@{"upsetStomach"@}=0;

$symptom=shift;
if(exists($state@{$symptom@}))@{print("$state@{$symptom@}\n");@}
else@{print("?\n");@}
@end example
  
Let's run this script that we are pretending to be complicated software to determine the value of the cough symptom.

@example
$./illnessConsult.pl cough
1
@end example
 
Now we'll create a new rule file called @code{illnessConsult.nb} to consult our Perl script.

@example
# File: tutorial/Ignorance/illnessConsult.nb
@b{use : ./illnessConsult.pl}
defineCommonCold on(cough and soreThroat);
defineFlu on(fever and achy and upsetStomach);
@b{query;}
@end example

Now we can diagnose an illness in batch mode.

@example
$ nb illnessConsult.nb
2008/06/1016:12:25 NB000I Argument [1] illnessConsult.nb
> # File: tutorial/Ignorance/illnessConsult.nb
> use : ./illnessConsult.pl
> define CommonCold on(cough and soreThroat);
> define Flu on(fever and achy and upsetStomach);
> query;
2008/06/1016:12:25 NB000T Resolving "fever" via command : ./illnessConsult.pl "fever"
Value=(0)
2008/06/1016:12:25 NB000T Resolving "cough" via command : ./illnessConsult.pl "cough"
Value=(1)
2008/06/1016:12:25 NB000T Resolving "soreThroat" via command : ./illnessConsult.pl "soreThroat"
Value=(1)
2008/06/1016:12:25 NB000I @b{Rule CommonCold fired}
2008/06/1016:12:25 NB000I Source file "illnessConsult.nb" included. size=149
2008/06/1016:12:25 NB000I NodeBrain nb[13690] terminating - exit code=0
$
@end example

In this example the consulted script @code{illnessConsult.pl} returned simple 0 and 1 values.  The interpreter will accept any valid cell expression and will attempt to resolve any term whose value is both unknown and needed.

@node Rules
@chapter Rules
@cindex rules

@quotation
@i{If you obey all the rules, you miss all the fun.}
 --- Katherine Hepburn
@end quotation

In this tutorial we'll see how much fun we can have making up rules and watching NodeBrain obey them.

@section When and if a rule fires on what

NodeBrain @code{on}, @code{when} and @code{if} rules have almost identical syntax. Their conditional cell expressions are resolved by the same cell evaluation algorithm.  Yet they respond differently to new information.  You can study these differences using rules that have no action.  Start by creating the following script called rules.nb.

@example
# File: tutorial/RuleTypes/rules.nb
define r0 when(a=1 and b=2);
define r1 on(a=1 and b=2);
define r2 on(a=2 and b=2);
define r3 if(a=1 and b=2);
assert a=1,b=2;
assert a=1,b=2;
assert a=2;
assert a=27;
alert a=1;
alert a=1;
@end example

When you execute this script you will notice that rules "fire" in response to assert and alert commands.

@example
$ nb rules.nb
2008/06/1016:54:24 NB000I Argument [1] rules.nb
> # File: tutorial/RuleTypes/rules.nb
> define r0 when(a=1 and b=2);
> define r1 on(a=1 and b=2);
> define r2 on(a=2 and b=2);
> define r3 if(a=1 and b=2);
> assert a=1,b=2;
2008/06/1016:54:24 NB000I Rule r0 fired
2008/06/1016:54:24 NB000I Rule r1 fired
> assert a=1,b=2;
> assert a=2;
2008/06/1016:54:24 NB000I Rule r2 fired
> assert a=27;
> alert a=1;
2008/06/1016:54:24 NB000I Rule r1 fired
2008/06/1016:54:24 NB000I Rule r3 fired
> alert a=1;
2008/06/1016:54:24 NB000I Rule r3 fired
2008/06/1016:54:24 NB000I Source file "rules.nb" included. size=206
2008/06/1016:54:24 NB000I NodeBrain nb[13859] terminating - exit code=0
$
@end example

Although rules r0, r1 and r3 are based on the same condition @code{(a=1 and b=2)}, they react differently to the @code{assert} and @code{alert} commands.

Q: Why didn't r3 fire on the first "@code{assert a=1,b=2;}" command?

A: Because @code{if} rules only respond to @code{alert} commands.

Q: Why didn't r1 fire on the second "@code{assert a=1,b=2;}" command?

A: Because @code{on} rules only fire when their condition transitions to true.  The second assertion made no change in the state of the condition.

Q: Why didn't r0 fire when r1 fired the second time?

A: Because @code{when} rules only fire once.  They are removed from the rule set once they fire.


Q: Why did r3 fire on the second "@code{alert a=1;}" command?

A: Because @code{if} rules fire on every @code{alert} command that leaves their condition in a true state.  Unlike @code{on} and @code{when} rules, they are not required to transition to a true state from a false or unknown state.

@section State Monitoring vs. Event Monitoring

In the previous example you may have noticed that NodeBrain supports both state and event monitoring.  The difference between the two is subtle.
The @code{assert} command and @code{on} rule are designed for state monitoring.
The @code{alert} command and @code{if} rule are designed for event monitoring.  But it isn't that simple.
The @code{on} rule responds to both @code{assert} and @code{alert} commands.  To an @code{on} rule, @code{alert} is just an alias for @code{assert}.  In fact, everything about the way an @code{alert} command is processed is identical to the way an @code{assert} command is processed, except @code{alert} brings @code{if} rules into play.  In other words, @code{alert} makes an assertion, and then says, "Oh, and by the way, this is an event to be considered by the @code{if} rules."

What makes our notion of state and event monitoring hard to untangle is the fact that we describe an event in the same way we describe a state, interpret an event as a new state, recognize state changes as events, and translate state changes into events.
Let's look at these confusing statements individually.

@example
# describe an event in the same way we describe a state
alert a=1,b=2;        # event
assert a=1,b=2;       # state 

# interpret an event as a new state
define r1 on(a=1 and b=2);
define r2 if(a=1 and b=2);
alert a=1,b=2;        # recognized as new state to both IF and ON rules
alert a=1,b=2;        # recognized as new state to IF rule, not to ON rule

# recognize state changes as events
define r1 on(a=1 and b=2);
assert a=0,b=0;
assert a=1,b=2;       # triggers internal events that cause r1 to fire

# translate state changes into events
define r1 on(a=1 and b=2): alert x="abc",y="def";
assert a=1,b=2;       # r1 translated state change into event(alert)
@end example

@node Syntax Surprises
@chapter Syntax Surprises
@cindex syntax, surprises

This section provides answers to some anticipated questions.

@section When do I use a semi-colon to end a command?

@quotation
@i{From now on, ending a sentence with a preposition is something up with which I will not put.}  --- Sir Winston Churchill (1874 - 1965)
@end quotation

NodeBrain does not require a semi-colon to terminate a command at the end of a line.  The following examples are both acceptable.

@example
> assert a=1,b=2;
> assert a=1,b=2
@end example

A semi-colon is required to terminate a command before a comment.

@example
> assert a=1,b=2; # This is valid
> assert a=1,b=2  # This is not valid
@end example

You can not put two commands on one line.

@example
> assert a=1,b=2; define x cell 10; # This is not valid
@end example

There are cases where a NodeBrain command ends with a command directed to another interpreter.  In those cases, you must follow the syntax rules of the other interpreter.  This is illustrated by the following rule that uses a host shell command as the action.

@example
> define psNb on(~(m)):-@b{ps -ef | grep nb}
@end example

@section How do I continue a command onto the next line?

There is no support for multiple line commands.  A new-line character ("\n") is always interpreted as the end of a command.

@section How can I specify multiple commands for a rule action?

If you are specifying multiple shell commands, the shell supports semi-colon @code{;} separated commands on a single line.

@example
> define r1 on(a=1 and b=2):= @b{myscript1.pl; rm*.foo; myscript2.pl}
@end example

You may also include multiple comma separated NodeBrain assertions.

@example
> define r1 on(a=1 and b=2) x=5,y="abc",z=20 := @b{myscript1.pl;rm *.foo; myscript2.pl}
@end example

If you need to specify multiple NodeBrain commands, they cannot be specified directly in the action of a rule.  But let's look at some alternatives.

If order is important, and you want to specify several commands, place the commands in a separate source file, and use the @code{source} command as the rule action.

@example
> define r1 on(a=1 and b=2):source r1Action.nb
@end example
You may also use a @code{-:} or @code{=:} (servant) command and have a servant script present multiple commands to the interpreter.

@example
> define r1 on(a=1 and b=2):-:r1Action.pl
@end example
If the order of the commands is not important, and the number is relatively small, you can use multiple rules with the same condition. To avoid typing the condition multiple times, specify the name of the first rule as the second rule's condition.

@example
> define r1 on(a=1 and b=2):-myscript1.pl
> define r2 on(r1): sally. alert x=5;
> define r3 on(r2): source r3Action.nb
@end example

Under the current implementation, you should not expect these rules to fire in any particular order.

@section How do I include quotes within a string?

This is not allowed.  Because NodeBrain is not a general purpose or report writing language, we have not yet found a reason to support quotes within a string.  When generating cell expressions manually or with a program, simply avoid generating values containing quotes.

@section Is there an escape sequence for including special characters in strings?

No, and we like it that way.  We have not found it necessary to use special characters in NodeBrain strings.  In commands sent to the host shell, and messages sent to servants or node modules, NodeBrain does not interfere with the use of any escape sequences supported by the target interpreter.
But NodeBrain is oblivious to it, and this is actually why there is no interference.
If a string value assigned to a NodeBrain term is ultimately destined to another interpreter (shell or node module), then you are free to include an escape sequence (except an escaped double quote). Again, NodeBrain is oblivious to it.

@node Tree
@chapter Tree Node
@cindex node, tree
@cindex tree node

@quotation
@i{A memory is what is left when something happens and does not completely unhappen.}
--- Edward de Bono
@end quotation

A tree node provides NodeBrain with a place to remember things that happen until they unhappen.
Actually that is true of simple cells as well.
The difference is that simple cells store one value while trees store multiple associated values.
So a tree can remember a more complex happening.
You can think of a tree node as a table of values.  Like a relational table, the values in a given row form a relation.
But we represent the table using a tree-of-trees structure and associate a value with each relation, including each left-to-right partial relation.
This enable us to test for the existence of a relation, or use a relation as a key for looking up a stored value.

@section Conditions

An expression of the form @i{tree(cell1,cell2,...)} can be used like a term in cell expressions.
We can assert values for these expressions and use then as conditions.
The @code{stuff.nb} file below illustrates these concepts.

@example
#!/usr/local/bin/nb
# File: tutorial/tree/stuff.nb
@b{define stuff node tree;}
define r1 on(stuff(x,y)>17 and stuff(x,y,z)="Sally");
stuff. assert ("Kathy","apple")=2,(1,2,3)="Sally",(1,2)=27;
assert x=1,y=2;
assert z=3;
show stuff
assert ?stuff(1,2);
show stuff
assert ?stuff(1,2,3);
show stuff
assert a=stuff("Kathy","apple");
show a
@end example

Study the execution below.
Do you know why rule r1 fires when it does?
Try rewriting the rule by replacing x, y, and z with their values at the time the rule fires.
Then replace the @code{stuff(...)} expressions in the rule with their values at the time the rule fires.

@example
$ ./stuff.nb
2009/01/31 12:36:15 NB000I Argument [1] ./stuff.nb
> #!/usr/local/bin/nb
> # File: tutorial/tree/stuff.nb
> define stuff node tree;
> define r1 on(stuff(x,y)>17 and stuff(x,y,z)="Sally");
> stuff. assert ("Kathy","apple")=2,(1,2,3)="Sally",(1,2)=27;
> assert x=1,y=2;
> assert z=3;
@b{2009/01/31 12:36:15 NB000I Rule r1 fired}
> show stuff
stuff = ? == node tree
  "Kathy"
    "apple"=2
  1
    2=27
      3="Sally"
> assert ?stuff(1,2);
> show stuff
stuff = ? == node tree
  "Kathy"
    "apple"=2
  1
    2
      3="Sally"
> assert ?stuff(1,2,3);
> show stuff
stuff = ? == node tree
  "Kathy"
    "apple"=2
> assert a=stuff("Kathy","apple");
> show a
a = 2
2009/01/31 12:36:15 NB000I Source file "./stuff.nb" included. size=301
2009/01/31 12:36:15 NB000I NodeBrain nb[24913] terminating - exit code=0
$
@end example

@section Watch Tables

Sometimes we use a tree node to specify a set of values to watch.
Here we use a simple tree to represent a list, or a table with a single column.
A multi-column table may be used if you want to watch for specific combinations
of event attributes.

@example
#!/usr/local/bin/nb
# File: tutorial/tree/watch.nb
@b{define watchtype node tree;}
@b{watchtype. assert ("tree fell"),("log rolled"),("frog croaked");}
@b{define r1 if(watchtype(type));}

# Sample events
alert type="tide out";
alert type="log rolled";
alert type="tide in";
alert type="frog croaked";
@end example

Notice how the following execution picks out the events of interest.

@example
./watch.nb
2009/01/31 12:56:27 NB000I Argument [1] ./watch.nb
> #!/usr/local/bin/nb
> # File: tutorial/tree/watch.nb
> define watchtype node tree;
> watchtype. assert ("tree fell"),("log rolled"),("frog croaked");
> define r1 if(watchtype(type));
> # Sample events
> alert type="tide out";
@b{> alert type="log rolled";}
2009/01/31 12:56:27 NB000I Rule r1 fired
> alert type="tide in";
@b{> alert type="frog croaked";}
2009/01/31 12:56:27 NB000I Rule r1 fired
2009/01/31 12:56:27 NB000I Source file "./watch.nb" included. size=289
2009/01/31 12:56:27 NB000I NodeBrain nb[26148] terminating - exit code=0
$
@end example

@section Event Sequence

We said earlier that a tree can be used to remember an event between the time it happens and unhappens.
Let's look at an example that provides a better illustration of this.

@example
#!/usr/local/bin/nb
# File: tutorial/tree/sequence.nb
@b{define jumped node tree;
define r1 if(event="jump" and ?jumped(name)) jumped(name);
define r2 if(event="land" and jumped(name)) ?jumped(name);
define r3 if(event="jump" and jumped(name)): @dots{}
@dots{} $ # $@{name@} jumped twice without intervening landing
define r4 if(event="land" and ?jumped(name)): @dots{}
@dots{} $ # $@{name@} landed twice without intervening jump}

# Sample events
alert event="jump",name="sally";
alert event="jump",name="joe";
alert event="land",name="sally";
alert event="land",name="joe";
alert event="jump",name="sally";
alert event="land",name="joe";
alert event="jump",name="sally";
@end example

In the execution below we were able to detect a couple things that happened and then happened again without first unhappening.

@example
2009/01/31 13:22:07 NB000I Argument [1] ./sequence.nb
> #!/usr/local/bin/nb
> # File: tutorial/tree/sequence.nb
> define jumped node tree;
> define r1 if(event="jump" and ?jumped(name)) jumped(name);
> define r2 if(event="land" and jumped(name)) ?jumped(name);
> define r3 if(event="jump" and jumped(name)): @dots{}
@dots{} $ # $@{namer@} jumped twice without an intervening landing
> define r4 if(event="land" and ?jumped(name)): @dots{}
@dots{} $ # $@{name@} landed twice without an intervening jump
> # Sample events
> alert event="jump",name="sally";
2009/01/31 13:22:07 NB000I Rule r1 fired (jumped(name)=1)
> alert event="jump",name="joe";
2009/01/31 13:22:07 NB000I Rule r1 fired (jumped(name)=1)
> alert event="land",name="sally";
2009/01/31 13:22:07 NB000I Rule r2 fired (jumped(name)=?)
> alert event="land",name="joe";
2009/01/31 13:22:07 NB000I Rule r2 fired (jumped(name)=?)
> alert event="jump",name="sally";
2009/01/31 13:22:07 NB000I Rule r1 fired (jumped(name)=1)
> alert event="land",name="joe";
2009/01/31 13:22:07 NB000I Rule r4 fired
@b{: # joe landed twice without an intervening jump}
> alert event="jump",name="sally";
2009/01/31 13:22:07 NB000I Rule r3 fired
@b{: # sally jumped twice without an intervening landing}
2009/01/31 13:22:07 NB000I Source file "./sequence.nb" included. size=631
2009/01/31 13:22:07 NB000I NodeBrain nb[26552] terminating - exit code=0
$
@end example

A tree node can support large trees if you have enough memory on your system. 
From a performance perspective tree nodes scale well because they are organized as binary trees that are kept reasonably balanced.
A lookup on a tuple (x,y,z) is performed as a binary search for x, followed by a binary search for y in a tree owned by (x), followed by a binary search for z in a tree owned by (x,y).


@node Cache
@chapter Cache Node
@cindex cache node
@cindex node, cache

@quotation
@i{There is a measure in everything. There are fixed limits beyond which and short of which right cannot find a resting place.}
--- Horace (65 BC - 8 BC)
@end quotation

A cache node, like a tree node, provides a place to remember events as associations, or relations.
But a cache adds to this the ability to measure repetition and variation within intervals of time and respond when predefined limits are reached.
It enables us to detect patterns of events that can be described as follows. 

@itemize @bullet
@item X happened N times within time period P or interval I.
@item X was associated with Y in N events within time period P or interval I.
@item X was associated with N different values of Y within time period P or interval I. 
@item X happened within interval I after Y happened.
@end itemize

Here X and Y represent the values of a set of one or more event attributes (A, B, C, ...).  For example, X might represent a (type, city) tuple while Y represents a (customer, item, quantity) tuple.
If you think of a cache as a table, which is sometimes a good way to visualize it, a @i{tuple} is just a table row.
If you think of a cache as a table-of-tables, a better way to visualize it, then Y is a row in a table associated with row X.

@section Thresholds

Here's a 24-hour cache node with 4 thresholds and 4 rules to respond when they are reached.
@example
#!/usr/local/bin/nb
# File: tutorial/cache/cache.nb
@b{define horace node cache:(~(24h):type(20),city@{10@}[5],customer,item,quantity(3));}
horace. define r1 if(type._hitState): $ # There have been $@{type._hits@} $@{type@} events
horace. define r2 if(city._rowState): @dots{}
@dots{} $ # ($@{type@},$@{city@}) had $@{city._rows@} different events
horace. define r3 if(city._kidState): @dots{}
@dots{} $ # ($@{type@},$@{city@}) had $@{city._kids@} different customers
horace. define r4 if(quantity._hitState): @dots{}
@dots{} $ # ($@{type@},$@{city@},$@{customer@},$@{item@},$@{quantity@}) happened $@{quantity._hits@} times
@end example

Here's a set of events represented as assertions to our 24-hour cache node named "horace".
@example
# File: tutorial/cache/events.nb
horace. assert ("purchase","Paris","Bruno","iPod",5);
horace. assert ("purchase","Paris","Bruno","iPod",5);
horace. assert ("purchase","Paris","Bruno","iPod",5);
horace. assert ("purchase","Paris","Bruno","shirt",2);
horace. assert ("purchase","Paris","Bruno","shoes",1);
horace. assert ("purchase","Paris","Madeleine","shoes",5);
horace. assert ("purchase","Paris","Madeleine","skirt",1);
horace. assert ("purchase","Paris","Madeleine","bread",2);
horace. assert ("purchase","Paris","Jeannine","bread",1);
horace. assert ("purchase","Paris","Laure","bread",1);
horace. assert ("purchase","Paris","Henri","iPod",1);
horace. assert ("return","Paris","Henri","iPod",1);
horace. assert ("return","Paris","Madeleine","iPod",1);
horace. assert ("purchase","London","Abigail","milk",1);
horace. assert ("purchase","London","Addie","bread",1);
horace. assert ("purchase","London","Alston","bread",1);
horace. assert ("purchase","London","Alston","candy",1);
horace. assert ("purchase","London","Alston","candy",2);
horace. assert ("purchase","London","Alston","candy",3);
horace. assert ("purchase","London","Alston","candy",4);
horace. assert ("purchase","London","Alston","candy",5);
horace. assert ("purchase","London","Alston","candy",6);
horace. assert ("purchase","London","Alston","candy",7);
horace. assert ("purchase","London","Alston","candy",8);
horace. assert ("purchase","London","Alston","candy",9);
@end example

Here's a sample execution.
@example
$ ./cache.nb events.nb
2009/01/31 09:10:04 NB000I Argument [1] ./cache.nb
> #!/usr/local/bin/nb
> # File: tutorial/cache/cache.nb
@b{> define horace node cache:(~(24h):type(20),city@{10@}[5],customer,item,quantity(3));}
> horace. define r1 if(type._hitState): @dots{}
@dots{} $ # There have been $@{type._hits@} $@{type@} events
> horace. define r2 if(city._rowState): @dots{}
@dots{} $ # ($@{type@},$@{city@}) had $@{city._rows@} different events
> horace. define r3 if(city._kidState): @dots{}
@dots{} $ # ($@{type@},$@{city@}) had $@{city._kids@} different customers
> horace. define r4 if(quantity._hitState): @dots{}
@dots{} $ # ($@{type@},$@{city@},$@{customer@},$@{item@},$@{quantity@}) happened $@{quantity._hits@} times
2009/01/31 09:10:04 NB000I Source file "./cache.nb" included. size=511
2009/01/31 09:10:04 NB000I Argument [2] events.nb
> # File: tutorial/cache/events.nb
> horace. assert ("purchase","Paris","Bruno","iPod",5);
> horace. assert ("purchase","Paris","Bruno","iPod",5);
> horace. assert ("purchase","Paris","Bruno","iPod",5);
2009/01/31 09:10:04 NB000I Rule horace.@b{r4 fired}
@b{: horace. # (purchase,Paris,Bruno,iPod,5) happened 3 times}
> horace. assert ("purchase","Paris","Bruno","shirt",2);
> horace. assert ("purchase","Paris","Bruno","shoes",1);
> horace. assert ("purchase","Paris","Madeleine","shoes",5);
> horace. assert ("purchase","Paris","Madeleine","skirt",1);
> horace. assert ("purchase","Paris","Madeleine","bread",2);
> horace. assert ("purchase","Paris","Jeannine","bread",1);
> horace. assert ("purchase","Paris","Laure","bread",1);
> horace. assert ("purchase","Paris","Henri","iPod",1);
2009/01/31 09:10:04 NB000I Rule horace.@b{r3 fired}
@b{: horace. # (purchase,Paris) had 5 different customers}
> horace. assert ("return","Paris","Henri","iPod",1);
> horace. assert ("return","Paris","Madeleine","iPod",1);
> horace. assert ("purchase","London","Abigail","milk",1);
> horace. assert ("purchase","London","Addie","bread",1);
> horace. assert ("purchase","London","Alston","bread",1);
> horace. assert ("purchase","London","Alston","candy",1);
> horace. assert ("purchase","London","Alston","candy",2);
> horace. assert ("purchase","London","Alston","candy",3);
> horace. assert ("purchase","London","Alston","candy",4);
> horace. assert ("purchase","London","Alston","candy",5);
> horace. assert ("purchase","London","Alston","candy",6);
2009/01/31 09:10:04 NB000I Rule horace.@b{r1 fired}
@b{: horace. # There have been 20 purchase events}
> horace. assert ("purchase","London","Alston","candy",7);
2009/01/31 09:10:04 NB000I Rule horace.@b{r2 fired}
@b{: horace. # (purchase,London) had 10 different events}
> horace. assert ("purchase","London","Alston","candy",8);
> horace. assert ("purchase","London","Alston","candy",9);
2009/01/31 09:10:04 NB000I Source file "events.nb" included. size=1407
2009/01/31 09:10:04 NB000I NodeBrain nb[27523] terminating - exit code=0
$
@end example

Ok, now why did rules r1, r2, r3, and r4 fire when they did?
Each time we assert a tuple to the cache, it updates a tree-of-trees structure as needed to retain the full set of asserted tuples.
It also updates three counters at each node within the tree-of-trees: hits, rows, and kids.
We define @i{hits} as the number of times an assertion arrives at a given node within the tree, @i{rows} as the number of subordinate table rows represented by the subordinate tree-of-trees, and @i{kids} as the number of directly subordinate nodes---or the number of unique values in the first column of the subordinate table.
In our definition of the "horace" cache node, we specified thresholds for hits using (), rows using @{@}, and kids using [].
When a threshold is reached, the cache node alerts itself.
The rules we defined for the node handle the alerts.
In the example above, when r4 fired, it was responding to an invisible alert that would look something like the following if it were not invisible.

@example
horace. alert quantity._hitState,quantity._hits=3,type="purchase",city="Paris", @dots{}
@dots{} customer="Bruno",item="iPod",quantity=5;
@end example

This alert was triggered because the hit counter for the (purchase,Paris,Bruno,iPod,5) node in our cache reached the specified limit of 3 within a 24-hour interval.
See if you can figure out why rules r1, r2, and r3 fired when they did.

In this example our rules just issue comment commands.
In a real application the rules would have taken action of some kind: an alert, assertion, alarm, shell command, etc.

@section Tuple Expiration 

A tuple in a cache can be retained for a defined time interval (e.g. 24-hours in our example above), until the end of a time period (e.g. end of current minute, hour, day), until some state is detected, or indefinitely.

@example
# interval
define horace node cache:(@b{~(24h)}:type(20),city@{10@}[5],customer,item,quantity(3));
# end of period
define horace node cache@b{(~(d))}:(type(20),city@{10@}[5],customer,item,quantity(3));
# state a=1
define horace node cache@b{(a=1)}:(type(20),city@{10@}[5],customer,item,quantity(3));
# indefinitely
define horace node cache:(type(20),city@{10@}[5],customer,item,quantity(3));
@end example

We can also remove a tuple or set of tuples from a cache at any time.  The following command removes all tuples starting with ("purchase","London").

@example
horace. assert @b{?}("purchase","London");
@end example

In addition to alerting when a threshold is reached, we can direct a cache to alert when a tuple expires.  This enables us to assert a tuple to the cache and take action if we haven't asserted it again within the expiration period.  In other word, we can use a cache to know when something hasn't happened for some interval of time.

@example
#!/usr/local/bin/nb
# File: tutorial/cache/tardy.nb
define tardy node cache:(@b{!}~(6s):Source);
tardy. define r1 if(_action="expire"): $ # $@{Source@} has been quiet for $@{_interval@}
tardy. assert ("Fred");
@end example

When executed below, we are notified that "Fred" has not been asserted to our cache for 6 seconds.
@example
./tardy.nb -
2009/01/31 10:38:06 NB000I Argument [1] ./tardy.nb
> #!/usr/local/bin/nb
> # File: tutorial/cache/tardy.nb
> define tardy node cache:(!~(6s):Source);
> tardy. define r1 if(_action="expire"): $ # $@{Source@} has been quiet for $@{_interval@}
> tardy. assert ("Fred");
> # Press the ENTER key once repeatedly until the rule fires
> # Should happen in 6 seconds
2009/01/31 10:38:06 NB000I Source file "./tardy.nb" included. size=290
2009/01/31 10:38:06 NB000I Argument [2] -
2009/01/31 @b{10:38:06} NB000I Reading from standard input.
---------- --------
>
>
>
>
>
>
2009/01/31 @b{10:38:12} NB000I Rule tardy.r1 fired
@b{: tardy. # Fred has been quiet for 6 seconds}
>
@end example

@section Event Sequence

A cache node can be used like a tree node for detecting a sequence of events.  However, the cache node, having support for scheduled tuple expiration, can also support a timing condition.
The @code{OnJust} cache below is used to remember for 5 seconds that a switch has been turned on.
The @code{TurnedOn} rule asserts the name of a switch to the cache each time a switch is turned on.
The @code{TurnedOff} rule responds to a switch being turned off if the cache still remembers the switch being turned on.

@example
#!/usr/local/bin/nb
# File: tutorial/cache/sequence.nb
define OnJust node cache:(~(5s):switch);
define TurnedOn if(on) OnJust(switch);
define TurnedOff if(!on and OnJust(switch)):@dots{}
@dots{} $ # The $@{switch@} turned off within $@{OnJust._interval@} of turning on

# Sample events
alert on,switch="kitchen light";
alert on,switch="porch light";
alert !on,switch="kitchen light";
-sleep 6
alert !on,switch="porch light";
alert on,switch="porch light";
alert !on,switch="porch light";
@end example

In the execution below, you will notice that the @code{TurnedOff} rule did not respond when the porch light stayed on for 6 seconds.

@example
$ ./sequence.nb
2009/01/31 11:23:14 NB000I Argument [1] ./sequence.nb
> #!/usr/local/bin/nb
> # File: tutorial/cache/sequence.nb
> define OnJust node cache:(~(5s):switch);
> define TurnedOn if(on) OnJust(switch);
> define TurnedOff if(!on and OnJust(switch)): @dots{}
@dots{} $ # The $@{switch@} turned off within $@{OnJust._interval@} of turning on
> alert on,switch="kitchen light";
2009/01/31 11:23:14 NB000I Rule TurnedOn fired (OnJust(switch)=1)
> alert on,switch="porch light";
2009/01/31 11:23:14 NB000I Rule TurnedOn fired (OnJust(switch)=1)
> alert !on,switch="kitchen light";
2009/01/31 11:23:14 NB000I Rule TurnedOff fired
: # The kitchen light turned off within 5 seconds of turning on
> -sleep 6
[6410] Started: -sleep 6
[6410] Exit(0)
@b{> alert !on,switch="porch light";}
> alert on,switch="porch light";
2009/01/31 11:23:20 NB000I Rule TurnedOn fired (OnJust(switch)=1)
> alert !on,switch="porch light";
2009/01/31 11:23:20 NB000I Rule TurnedOff fired
: # The porch light turned off within 5 seconds of turning on
2009/01/31 11:23:20 NB000I Source file "./sequence.nb" included. size=453
2009/01/31 11:23:20 NB000I NodeBrain nb[6409] terminating - exit code=0
@end example

@section Event Correlation

A cache node is useful for event correlation where the goal is to detect repetition, variation, or sequence.
Rules can be used to recognize input events and assert multiple attribute combinations (tuples) to different cache
nodes to detect different patterns.
A single cache can detect multiple patterns, but it often necessary to specify attributes in a different order in different cache nodes to detect all the required patterns.
For example, a cache specified as (child,action[5],toy) could detect a given child taking a given action on 5 different toys, while a cache specified as (toy[10],child[3],action(7)) could detect when 10 different children performed a given action on a given toy, a given child performed 3 different actions on a given toy, and a given child performed a given action on a given toy 7 times.  The last condition could be detected by the first cache if we included another threshold, (child,action[5],toy(7)).
But the first two conditions detected by the second cache could not be detected by the first cache.
It is necessary to use two different cache nodes with the attributes in a different order to detect all 4 conditions.


@node Servant
@chapter Servant Node
@cindex servant node
@cindex node, servant

@quotation
@i{In order to become the master, the politician poses as the servant.}
--- Charles De Gaulle (1890 - 1970)
@end quotation

NodeBrain is not intended to be the master of all things.  As in politics, it is often more convenient to let a servant be the master.  In this tutorial you will learn how to create a servant in your favorite programming language to obtain information needed to make decisions.  You will see that when a servant sends commands to NodeBrain, it becomes the master---like a politician once elected.

@section Creating a Servant Program

To keep it simple and only hint at something useful, let's create a servant script using Perl that pretends to tell us the cost of gas and bread, something every politician should be prepared to include in a campaign speech.

@example
#!/usr/bin/perl
# File: tutorial/Servant/charles.pl
my $gas=2.50;
my $bread=1.10;
$|=1;
while(<>)@{
  chomp($_);
  if(/gas/)@{print("assert gas=$gas;\n");$gas+=.50;@}
  elsif(/bread/)@{print("assert bread=$bread;\n");$bread+=.25@}
  else@{print("alert msg=\"item '$_' not recognized\";\n");@}
  @}
@end example

@section Specifying a Servant Node

Now we need some rules to use our servant program.  Create a script that looks like this.

@example
#!/usr/local/bin/nb -s
# File: tutorial/Servant/charles.nb
@b{define price node servant:|=|:./charles.pl}
define ouch on(gas>4 or bread>3):stop;
define getgasprice on(~(3s)):price:gas
define getbreadprice on(~(3s)):price:bread
@end example

The Servant node module specification includes an @code{=} command to specify the program and what to do with stdout and stderr.
It also supports a leading @code{|} to enable the sending of text to the program on stdin.

@section Execution

This script is designed to run like an agent without detaching from the terminal.  The @code{-s} option is the trick.  The script will pause for 3 seconds between scheduled events, so just be patient and the script will end when the price of one of the items gets too painful.

@example
$ ./charles.nb
2008/08/21 19:08:28 NB000I Argument [2] ./charles.nb
> #!/usr/local/bin/nb -s
> # File: tutorial/Servant/charles.nb
> define price node servant:|=|:./charles.pl
> define ouch on(gas>4 or bread>3):stop;
> define getgasprice on(~(3s)):price:gas
> define getbreadprice on(~(3s)):price:bread
2008/08/21 19:08:28 NB000I Source file "./charles.nb" included. size=194
2008/08/21 19:08:28 NB000T Servant mode selected
---------- ----------------------------------------------------
2008/08/21 19:08:28 NM000I servant price: Enabling|=|:./charles.pl
2008/08/21 19:08:28 NM000I servant price: Enabled[21633] |=|:./charles.pl
2008/08/21 19:08:31 NB000I Rule getbreadprice fired
: price:bread
2008/08/21 19:08:31 NB000I Rule getgasprice fired
: price:gas
> price. assert bread=2.1;
> price. assert gas=3.25;
2008/08/21 19:08:34 NB000I Rule getbreadprice fired
: price:bread
2008/08/21 19:08:34 NB000I Rule getgasprice fired
: price:gas
> price. assert bread=2.35;
> price. assert gas=3.75;
2008/08/21 19:08:37 NB000I Rule getbreadprice fired
: price:bread
2008/08/21 19:08:37 NB000I Rule getgasprice fired
: price:gas
> price. assert bread=2.6;
> price. assert gas=4.25;
2008/08/21 19:08:37 NB000I Rule ouch fired
: stop;
2008/08/21 19:08:37 NB000I [21633] Killed(1)
2008/08/21 19:08:37 NB000I NodeBrain nb[21632] terminating - exit code=0
@end example


@node Translator
@chapter Translator Node
@cindex translator node
@cindex node, translator

@quotation
@i{I don't mind what language an opera is sung in so long as it is a language I don't understand.}
--- Sir Edward Appleton (1892 - 1965)
@end quotation

NodeBrain supports rules used to translate an opera into NodeBrain commands.  Well, okay, not exactly an opera, but lines of text conforming to some foreign syntax for which the significant elements can be recognized and extracted with regular expressions.  The desired translation is specified in a NodeBrain translation rule file called a "translator".  This capability is made available to node modules via the API.  The Translator node module is a simple example of one that uses NodeBrain's translator feature. 

@section Foreign Text

We'll start this tutorial with a file named @file{opera.txt} containing the text of a Mother Goose rhyme.

@example
# File: tutorial/Translator/opera.txt
#
# Mother Goose Nursery Rhyme
# The Man Who Had Naught
#
There was a man and he had naught,
  And robbers came to rob him;
He crept up to the chimney pot,
  And then they thought they had him.

But he got down on t'other side,
  And then they could not find him;
He ran fourteen miles in fifteen days,
  And never looked behind him.
@end example

@section Translator File

A translator recognizes elements of foreign text and converts it into NodeBrain commands.  Let's create one called @file{opera.nbx} that can be used to translate files that look like our @file{opera.txt} file.  

@example
# File: tutorial/Translator/opera.nbx
#

# Ignore lines starting with "#"
(^#)

# Pick up lines with "had" followed by a word,
# but continue on looking for other matches
# even when a match is found.
@@(had (\w*)):alert type="Had",what="$[1]";

# Look for "he had" lines - will be subset of "had" lines
(he had (\w*)):alert type="HeHad",what="$[1]";

# Look for lines starting with "And".
(^\s*And )@{
  (^then they )@{
    (thought)
    :assert info="$[=]";
    @}
  (^(\w*) )[$[1]]@{
    "robbers":assert info="bad guys $[>]";
    "never":assert info="they didn't $[>]";
    @}
  @}

# Look for "He <verb>" lines.
(^He (crept|ran) )@{
  @@"fourteen miles in fifteen days,":assert info="slow runner this man who had naught";
  :assert heVerb="$[1]";
  @}
@end example
 
The lines starting with "(" specify a regular expression up to the balanced ")" to be matched against lines of foreign text.
The first matching expression determines the translation; that is, the translator stops on a match and subsequent expressions are not evaluated.
However, if you start the line with "@@(" instead, the translator will continue even after a match.  

If nothing follows the expression, as with "@code{(^#)}" and "@code{(thought)}" above, the translator takes no action on a match.
This means all lines starting with "#" will translate into nothing.  You could say they are ignored or suppressed.

An expression can also be followed by a single action, like the @code{@@(had (\w*))} and @code{(he had (\w*))} expressions which are followed by "@code{:alert ...}".

When an expression is followed by "@{", a nested translator is specified up until the following "@}".
A nested translator matches against the text following the previous match.
Let's consider the input line "And then they thought they had him."
When this line matches @code{(^s*And )} in our translator,
the nested translation block will work on "then they thought they had him."
After a match on @code{(^then they )}, nested translation continues trying to match "thought they had him."

NodeBrain commands are passed to the interpreter with an expression starting with colon ":" to distinguish them from other operations supported by the translator.
A $[@i{n}] in the command is replaced with the string matching the @i{n}'th parenthetical sub-expression, starting at 0 for the outer parentheses.
A $[=] is replaced with the text being matched, and $[>] is replaced with the text following the last match.

The text buffer can be replaced with an expression of the form @code{[@i{text}]}.
In our example above, the @code{[$[1]]} following @code{(^(\w*) )} replaces the text buffer with the matched word.

Strings enclosed in double quotes (e.g. @code{"robbers"}) specify an exact match.  When strings are used, they must be placed at the start of a block.  NodeBrain likes to look for exact matches before regular expressions.

@section Rule File using Translator Node

A translator works in concert with NodeBrain rules---hopefully not as difficult to understand as an operatic concert.
Here's a rule file called @code{opera.nb} designed to work with our translator above.

@example
#!/usr/local/bin/nb
# File: tutorial/Translator/opera.nb
@b{define opera node translator("opera.nbx");}
opera. define r1 on(info~"they didn't");
opera. define r2 if(type="HeHad");

@b{opera:And robbers got away.}
opera:And never mind.
opera:And never worry.
@b{opera("translate"):opera.txt}

@end example
  
The first highlighted line defines a translator node that uses our @code{opera.nbx} translator.  Then we define two rules, r1 and r2, that do nothing except enable us to demonstrate that a rule can fire in response to foreign text.
  
The second highlighted line, which starts with "opera:", sends foreign text to the translator node for translation.
The last highlighted line, starting with "opera(", directs the translator nodes to translate our foreign text file @file{opera.txt}. 

@page
@section Lost in Translation

When your execute @file{opera.nb}, you should see something like this.  

@example
$ ./opera.nb
2009/01/28 17:49:27 NB000I Argument [1] ./opera.nb
> #!/usr/local/bin/nb
> # File: tutorial/Translator/opera.nb
> define opera node translator("opera.nbx");
@b{2009/01/28 17:49:27 NB000I Loading translator "opera.nbx"}
---------- --------
# File: tutorial/Translator/opera.nbx
#

# Ignore lines starting with "#"
(^#)

# Pick up lines with "had" followed by a word,
# but continue on looking for other matches
# even when a match is found.
@@(had (\w*)):alert type="Had",what="$[1]";

# Look for "he had" lines - will be subset of "had" lines
(he had (\w*)):alert type="HeHad",what="$[1]";

# Look for lines starting with "And".
(^\s*And )@{
  (^then they )@{
    (thought)
    :assert info="$[=]";
    @}
  (^(\w*) )[$[1]]@{
    "robbers":assert info="bad guys $[>]";
    "never":assert info="they didn't $[>]";
    @}
  @}

# Look for "He <verb>" lines.
(^He (crept|ran) )@{
  @@"fourteen miles in fifteen days,":assert info="slow runner this man who had naught";
  :assert heVerb="$[1]";
  @}
---------- --------
2009/01/28 17:49:27 NB000I Translator "opera.nbx" loaded successfully.
@end example
@dots{} continued on next page @dots{}
@example
> opera. define @b{r1} on(info~"they didn't");
> opera. define @b{r2} if(type="HeHad");
> opera:And robbers got away.
> opera. assert info="bad guys got away.";
> opera:And never mind.
> opera. assert info="they didn't mind.";
@b{2009/01/28 17:49:27 NB000I Rule opera.r1 fired}
> opera:And never worry.
> opera. assert info="they didn't worry.";
> opera("translate"):opera.txt
---------- --------> opera.txt
> opera. alert type="Had",what="naught";
> opera. alert type="HeHad",what="naught";
@b{2009/01/28 17:49:27 NB000I Rule opera.r2 fired}
> opera. assert info="bad guys came to rob him;";
> opera. assert heVerb="crept";
> opera. alert type="Had",what="him";
> opera. assert info="could not find him;";
> opera. assert info="slow runner this man who had naught";
> opera. assert heVerb="ran";
> opera. assert info="they didn't looked behind him.";
@b{2009/01/28 17:49:27 NB000I Rule opera.r1 fired}
---------- --------< opera.txt
2009/01/28 17:49:27 NB000I Source file "./opera.nb" included. size=237
2009/01/28 17:49:27 NB000I NodeBrain nb[16261] terminating - exit code=0
$
@end example

As an exercise, you should perform the translation yourself to make sure you understand what is going on here.
At least focus on the lines around the first firing of rule opera.r1, starting with "opera:And never mind."
Walk "And never mind." through the translator to see why it emits @code{assert info="they didn't mind."} triggering r1.
Do you understand why "opera:And never worry." emits a similar assertion without trigging r1?
It is a characteristic of NodeBrain's @code{on} rule and the fact that the condition didn't change. 
An @code{if} rule would have fired both times.

We said that our translator @file{opera.nbx} is designed to operate on lines like those found in @file{opera.txt}, and we said that our rule file @file{opera.nb} is designed to work with our translator. 
You may have noticed that our translator was not designed specifically to work with our rules, because
it emits commands that give us information our rules don't need.
In many cases, a translator and a set of rules are designed together and the
translator only emits information that is used by the rules.

@node Audit
@chapter Audit Node
@cindex audit node
@cindex node, audit

@quotation
@i{If Edison had a needle to find in a haystack, he would proceed at once with the diligence of the bee to examine straw after straw until he found the object of his search... I was a sorry witness of such doings, knowing that a little theory and calculation would have saved him ninety per cent of his labor.}
--- Nikola Tesla (1857- 1943), New York Times, October 19, 1931
@end quotation

Effective review of system and application logs can be like trying to find a needle in a haystack.  It requires at least one Edison and one Tesla working as a team.
The Audit node module works like Edison when reviewing logs so you can work like Tesla.

An Audit node is similar to the Translator node covered in an earlier tutorial, but differs in the way lines of text are input for translation.
An Audit node starts at the end of a log file and periodically checks for new lines to translate.  When a log file rolls, the audit node starts at the beginning of the new log file.

The content of system and application log files can vary significantly depending on the mix of applications on a system and how they are configured.  A good strategy is to treat log entries as worthy of investigation by default.  Duplicate suppression and other flood protection techniques are helpful when using this strategy.  As new log entries are reported and investigated, you can decide if they should be suppressed or handled in a special way.

@section Agent Rules

The @file{syslog.nb} file below provides an agent with an audit node to monitor a log file called @file{syslog}.  
It specifies a translator named @file{syslog.nbx} and a polling interval of 10 seconds.
(A longer interval is recommended for real application.)
We have also included a deduplication cache.
@example
#!/usr/local/bin/nb -d
# File: tutorial/Audit/syslog.nb
set log="syslog.log",out=".";
define syslog node cache(~(h(8))):(~(1h):route,appl,group,node,object,severity,text(1));
syslog. define alarm if(text._hitState):$ -|mail.form @dots{}
@dots{} source=tutorial route="$@{route@}" appl="$@{appl@}" group="$@{group@}" @dots{}
@dots{} node="$@{node@}" severity="$@{severity@}" text="$@{text@}" >> mail.log
@b{syslog. define audit node audit("syslog","syslog.nbx",~(10s));}
@end example

@section Sample Log

Here's a small sample of a log file in the format we'll use for this tutorial.
A copy of this file is stored as @file{tutorial/Audit/syslog.sample}.

@example
Feb  1 19:00:04 smk001 sshd[3972]: Accepted publickey for myuser @dots{}
@dots{} from ::ffff:192.168.1.100 port 53403 ssh2
Feb  1 19:00:06 smk001 sshd[3980]: Accepted publickey for myuser @dots{}
@dots{} from ::ffff:192.168.1.101 port 53410 ssh2
Feb  1 19:00:16 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:00:46 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:01:16 smk001 kernel: z90crypt: probe_crypto_domain -> @dots{}
@dots{} Unable to find crypto domain: No devices found
Feb  1 19:01:19 smk001 su: (to root) myuser on /dev/pts/1
@end example

@section Translation Rules

Here's a small translator called @file{syslog.nbx} designed for the log format above.

@example
# File: tutorial/Audit/syslog.nbx
([a-zA-Z]+ +\d+ \d\d:\d\d:\d\d [^ ]+ )@{
  (^-- MARK --)
  (^\/USR\/SBIN\/CRON\[\d+\]: [^ ]+ CMD)
  (^last message repeated \d+ times)
  (^kernel: )@{
    (^z90crypt: probe_crypto_domain -> Unable to find crypto domain: No devices found)
    (^end_request: I\/O error)
    (^dasd_erp.*:Perform logging requested)
    (^dasd:.*:ERP successful)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 kernel: $[=]");
    @}
  (^su: )@{
    (^pam_unix2: session (started|finished) for user (nobody|root|wwwadm|cyrus), service su)
    (^\(to (nobody|cyrus)\) root on none)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 su: $[=]");
    @}
  (^sshd\[\d+\]: )@{
    (^Accepted password for myuser from ::ffff:.* port \d+ ssh2)
    (^Accepted publickey for myuser from ::ffff:.* port \d+ ssh2)
    (^error: Could not get shadow information for NOUSER)
    (^(?'preport'.*port) \d+ )@{
      :syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
      @dots{} "SYS0000 sshd[*]: $[preport]port * $[=]");
      @}
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 sshd[*]: $[=]");
    @}
  @}
():syslog. assert ("syslog","syslog","OS","","","critical","SYS0000 $[-]");
@end example

@page
@section Start the Agent

Before starting the agent you must touch a file named @file{syslog} to make sure it exists.

@example
$ ./syslog.nb
2009/02/01 19:56:57 NB000I Argument [1] -d
2009/02/01 19:56:57 NB000I Argument [2] ./syslog.nb
> #!/usr/local/bin/nb -d
> # File: tutorial/Audit/syslog.nb
> set log="syslog.log",out=".";
2009/02/01 19:56:57 NB000I NodeBrain nb will log to syslog.log
> define syslog node cache(~(h(8))):(~(1h):route,appl,group,node,object,severity,text(1));
> syslog. define alarm if(text._hitState):$ -|mail.form @dots{}
@dots{} source=tutorial route="$@{route@}" appl="$@{appl@}" group="$@{group@}" @dots{}
@dots{} node="$@{node@}" severity="$@{severity@}" text="$@{text@}" >> mail.log
> syslog. define audit node audit("syslog","syslog.nbx",~(10s));
2009/02/01 19:56:57 NB000I Loading translator "syslog.nbx"
---------- --------
# File: tutorial/Audit/syslog.nbx
([a-zA-Z]+ +\d+ \d\d:\d\d:\d\d [^ ]+ )@{
  (^-- MARK --)
  (^\/USR\/SBIN\/CRON\[\d+\]: [^ ]+ CMD)
  (^last message repeated \d+ times)
  (^kernel: )@{
    (^z90crypt: probe_crypto_domain -> Unable to find crypto domain: No devices found)
    (^end_request: I\/O error)
    (^dasd_erp.*:Perform logging requested)
    (^dasd:.*:ERP successful)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 kernel: $[=]");
    @}
  (^su: )@{
    (^pam_unix2: session (started|finished) for user (nobody|root|wwwadm|cyrus), service su)
    (^\(to (nobody|cyrus)\) root on none)
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 su: $[=]");
    @}
  (^sshd\[\d+\]: )@{
    (^Accepted password for myuser from ::ffff:.* port \d+ ssh2)
    (^Accepted publickey for myuser from ::ffff:.* port \d+ ssh2)
    (^error: Could not get shadow information for NOUSER)
    (^(?'preport'.*port) \d+ )@{
      :syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
      @dots{} "SYS0000 sshd[*]: $[preport]port * $[=]");
      @}
    :syslog. assert ("syslog","syslog","OS","","","normal","SYS0000 sshd[*]: $[=]");
    @}
  @}
():syslog. assert ("syslog","syslog","OS","","","critical","SYS0000 $[-]");
---------- --------
2009/02/01 19:56:57 NB000I Translator "syslog.nbx" loaded successfully.
2009/02/01 19:56:57 NB000I Source file "./syslog.nb" included. size=425
2009/02/01 19:56:57 NB000I NodeBrain nb[6749,3352] daemonizing
$
@end example

@section Grow the Log

We'll just use a shell script to append our sample log file @file{syslog.sample} to the monitored @file{syslog} file three times.

@example
# File: tutorial/Audit/syslog.sh
cat syslog.sample >> syslog
cat syslog.sample >> syslog
cat syslog.sample >> syslog
@end example

@section Review the Agent Log

After executing the @file{syslog.sh} script above, your @file{syslog.log} file should look like this.

@example
2009/02/01 19:59:35 NB000I Agent log is syslog.log
2009/02/01 19:59:35 NM000I audit audit: Enabled audit of syslog using syslog.nbx
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
2009/02/01 20:00:05 NB000I Rule syslog.alarm fired
: syslog. -|mail.form source=tutorial route="syslog" appl="syslog" group="OS" @dots{}
@dots{} node="" severity="normal" text="SYS0000 su: (to root) myuser on /dev/pts/1" >> mail.log
[6957] Started: -|mail.form source=tutorial route="syslog" appl="syslog" group="OS" @dots{}
@dots{} node="" severity="normal" @dots{}
@dots{} text="SYS0000 su: (to root) myuser on /dev/pts/1" >> mail.log
[6957] Exit(0)
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
> syslog. assert ("syslog","syslog","OS","","","normal", @dots{}
@dots{} "SYS0000 su: (to root) myuser on /dev/pts/1");
@end example

Notice that the translator only asserted the su log entries to the syslog cache.
This is because our translator was coded to ignore the other entries in our sample log file.
Notice also that the agent only generated an alarm once.
This is because the syslog cache node was coded to ignore duplicates until 8:00 AM unless they are separated by 1 hour.

Although we used a system log for this tutorial, you can code up a translator for application logs as well.
In fact, the more unique your application log, the more likely you will need to construct your own custom log monitor
with one of the many tools like this.

If you started the agent for this tutorial, you should kill it now.


@node Syslog
@chapter Syslog Node
@cindex syslog node
@cindex node, syslog

@quotation
I decided that it was not wisdom that enabled [poets] to write their poetry, but a kind of instinct or inspiration, such as you find in seers and prophets who deliver all their sublime messages without knowing in the least what they mean.
--- Socrates (469 BC - 399 BC), In "Apology," sct. 21, by Plato.
@end quotation

If your sublime messages are delivered via the syslog protocol, you may prefer to use a syslog node instead of an audit node.
This enables NodeBrain to respond immediately to arriving syslog UDP packets without waiting to poll a log file.

You have a couple options.
You can configure your syslog node to listen on UDP port 514 on a server that doesn't already have a syslog daemon.
However, if you need (or want) more flexibility, we recommend that you use NodeBrain in combination with syslog-ng.
In that case, you configure NodeBrain to listen on a different port and configure syslog-ng to forward all or selected syslog entries to NodeBrain.

The example below is configured to listen on UDP port 1514, assuming syslog-ng is used to forward syslog to NodeBrain.

@example
#!/usr/local/bin/nb -d
# File: tutorial/Syslog/syslog.nb
-rm syslog.log
set log="syslog.log",out=".";
define syslog node cache(~(h(8))):(~(1h):route,appl,group,node,object,severity,text(1));
syslog. define alarm if(text._hitState):$ -|mail.form @dots{}
@dots{} source=tutorial route="$@{route@}" appl="$@{appl@}" group="$@{group@}" @dots{}
@dots{} node="$@{node@}" severity="$@{severity@}" text="$@{text@}" >> mail.log
@b{syslog. define audit node syslog("syslog.nbx",1514);}
@end example

You should reference the documentation for syslog-ng to see how to configure it to forward to NodeBrain.
Here's an example to get you started.

@example
destination nodebrain @{ udp("localhost" port(1514)); @};
filter f_nodebrain @{ host("(humpty|dumpty).mydomain.com|franklin.otherdomain.com"); @};
log @{ source(src);  filter(f_nodebrain); destination(nodebrain); @};
@end example

Refer to the @i{Audit Node} tutorial above for a sample @file{syslog.nbx} file.
Refer to the @i{Translator Node} tutorial for more information on coding a translator.

@node Snmptrap
@chapter Snmptrap Node
@cindex snmptrap node
@cindex node, snmptrap

@quotation
Man is the only kind of varmint who sets his own trap, baits it, then steps on it.
--- John Steinbeck (1902 - 1968)
@end quotation
The snmptrap node is used to monitor SNMP traps.
This is one method of configuring NodeBrain to accept alerts from monitoring tools that are capable of sending SNMP traps.
NodeBrain's snmptrap node is a bit unusual in that it does not use MIB's.  Instead, each trap is converted into a NodeBrain alert using single quoted OID terms.

@example
alert '@i{oid}'="@i{value}",'@i{oid}'="@i{value}",...;
@end example

You must then code your rules referencing the '@i{oid}' terms.
However, we recommend that you define aliases for the OID's of interest to make your rules more readable.

@example
#!/usr/local/bin/nb -d
# File: tutorial/Snmptrap/snmptrap.nb
-rm snmptrap.log
set log="snmptrap.log",out=".";
# Node
@b{define snmptrap node snmptrap:trace,dump;}
# Aliases
snmptrap. define myProduct cell '1.3.6.1.6.3.1.1.4.3'="1.3.6.1.4.1.1279";
snmptrap. define address cell '1.3.6.1.4.1.1279.4';
snmptrap. define type    cell '1.3.6.1.4.1.1279.5';
# Rules
snmptrap. define r1 if(myProduct and type="hiccup");
@end example

The example above is only provided to illustrate the syntax for working with single quoted OID terms.
You will need to adapt this example to the traps you want to monitor to construct useful rules.
However, you can use this example to start collecting traps right away.
The traps will show up in your @file{snmptrap.log} file.
Then you can figure out what you want to monitor.

Remove the ":trace,dump" from your snmptrap node specification to reduce the amount of information in your log.
@example
@b{define snmptrap node snmptrap;}
@end example

You may use a "silent" option to stop logging the alerts generated by the snmptrap node.
@example
@b{define snmptrap node snmptrap:silent;}
@end example

@node Pipe
@chapter Pipe Node
@cindex pipe node
@cindex node, pipe

@quotation
@i{To listen closely and reply well is the highest perfection we are able to attain in the art of conversation.}
--- Francois de La Rochefoucauld (1613 - 1680)
@end quotation

To construct a successful NodeBrain application we must configure NodeBrain to listen closely and respond well.  The "Operating Mode Tutorial" illustrates how NodeBrain can listen for input commands from stdin and both input commands and error messages from servant scripts.   NodeBrain's ability to listen is controlled by a component called the "medulla".   Node modules interface with the medulla to extend NodeBrain's ability to listen to include other sources of input.  

A pipe node is perhaps the simplest of listening nodes.  It listens to a FIFO (named pipe) file, and you can write to the
pipe using any program you like, including an @code{echo} command.

@section Defining Pipe Server Nodes

We begin this tutorial by creating an agent script called smokey.nb with two pipe server nodes as shown here.

@example
#!/usr/local/bin/nb -d
# File: tutorial/Pipe/smokey.nb
-rm smokey.log
setlog="smokey.log",out=".";
@b{declare jed identity guest;}
@b{declare chief identity owner;}
@b{define corncob node pipe.server("jed@@corncob");}
corncob.define r1 on(a=1 and b=2);
@b{define peace node pipe.server("chief@@peace");}
peace.define r1 on(a=1 and b=2);
@end example

The argument to a pipe.server is of the form "@i{identity}@@@i{pipe}".
Identities are associated with listening nodes to limit the types of commands the interpreter will accept from the node.  In this example we associate the identity "jed" with the corncob pipe, and the identity "chief" with the peace pipe.
We have declared jed to be a guest and chief to be an owner.  A guest can only connect and issue @code{show} commands---like read only access.
An owner can issue any command, including shell commands, which means they have all permissions of the user that started the agent.  For this reason, pipes are created with owner only read/write permissions.
However, if you declare the associated identity to be a "peer", you can give other user's write permission on the pipe.
They will be able to issue assertions and alerts, but not modify your rules or issue shell commands.
You must still think through how the agent will respond to their assertions.
For example, if you create a rule that reboots the system when a=1, then letting someone assert a=1 is the same as letting them reboot the system.

@section Starting Pipe Server Agent

Now let's start our agent.  We've made this script executable and specified the @code{-d} (daemon) option on the she-bang line.  So we can just execute it like any executable and it will load the rules and go into the background (daemonize).

@example
$ ./smokey.nb
2008/06/1017:09:16 NB000I Argument [1] -d
2008/06/1017:09:16 NB000I Argument [2] ./smokey.nb
> #!/usr/local/bin/nb -d
> # File: smokey.nb
> -rm smokey.log
[13993]Started: -rm smokey.log
[13993]Exit(0)
> set log="smokey.log",out=".";
2008/06/1017:09:16 NB000I NodeBrain nb will log to smokey.log
> declare jed identity guest;
> declare chief identity owner;
> define corncob node pipe.server("jed@@corncob");
> corncob. define r1 on(a=1 and b=2);
> define peace node pipe.server("chief@@peace");
> peace. define r1 on(a=1 and b=2);
2008/06/1017:09:16 NB000I Source file "./smokey.nb" included. size=323
2008/06/1017:09:16 NB000I NodeBrain nb[13992,4118] daemonizing
$
@end example

@section Sending Commands to Pipe Server Nodes

We'll use the echo command to send NodeBrain commands to our pipe servers.

@example
$ echo stop > corncob
$ echo stop > peace
@end example

The log file shows us what happened.

@example
$ @b{cat smokey.log}

N o d e B r a i n   0.7.0(Dunce) 2008/05/24

Compiled Jun 10 2008 15:30:28s390x-ibm-linux-gnu

Copyright (C) 1998-2008 The Boeing Company
GNU General Public License
----------------------------------------------------------------

/usr/local/bin/nb -d ./smokey.nb

Date       Time     Message
---------- ----------------------------------------------------
2008/06/10 17:09:16 NB000I NodeBrain nb[13994:1] myuser@@myhost
2008/06/10 17:09:16 NB000I Agent log is smokey.log
2008/06/10 17:09:16 NM000I pipe.server peace: Listening for FIFO connections as chief@@peace
2008/06/10 17:09:16 NM000I pipe.server corncob: @dots{}
@dots{} Listening for FIFO connections as jed@@corncob
2008/06/10 17:41:11 NM000I pipe.server corncob: FIFO jed@@corncob
> corncob. stop
2008/06/10 17:41:11 NB000E @b{Identity "jed" does not have authority to issue stop command.}
2008/06/10 17:41:19 NM000I pipe.server peace: FIFO chief@@peace
> peace. stop
2008/06/10 17:41:19 NB000I NodeBrain nb[13994] terminating - exit code=0
$
@end example

Notice that when we sent a @code{stop} command to the corncob pipe we didn't have the needed authority, but when we sent the same @code{stop} command to the peace pipe it worked.  
  
Run smokey.nb again with the following commands to see what happens.

@example
$ ./smokey.nb
$ echo "common. define r1 on(a=1 and b=2);" > peace
$ echo "common. assert a=1,b=3;" > peace
$ echo "common. assert b=2;" > peace
$ echo "common. show -t" > peace
$ echo "stop" > peace
$ cat smokey.log
@end example

@node Peer
@chapter Peer Node
@cindex peer node
@cindex node, peer

@quotation
@i{The more elaborate our means of communication, the less we communicate.}
--- Edwin Schlossberg
@end quotation
  
The peer module is more elaborate than some of the other modules used for communication.  The goal is to communicate less, or at least to be more selective in with whom we communicate.  This selectivity is accomplished with encryption and key based authentication.

The files for this tutorial are in the tutorial/Peer directory.  The NodeBrain scripts are executable and we have left the @code{.nb} suffix off for fun.

@section Peer Module Identity Keys

Before we communicate using the peer module, we must create keys to be used by clients and servers.  To reduce complexity for this example, we'll create a single key and use it for both the client and the server as a "shared secret" key.  Here's a script called @file{genkey} that creates a key for an identity called @code{buddy}.

@example
#!/usr/local/bin/nb
# File: tutorial/Peer/genkey
@b{define myService node peer.service;}
@b{myService:identify buddy;}
@end example

The peer module provides a skill called @code{service} that supports some helpful commands associated with peer communication.
We are using the @code{identify} command here.
This command generates a key and places it in a key store for later reference.

@multitable {----------------------} {----------------------------------------------------------------------------------}
@item Unix and Linux: @tab ~/.nb/nb_peer.keys
@item Windows: @tab USER_PROFILE/ApplicationData/NodeBrain/nb_peer.keys
@end multitable

The key store is readable only by the owning user and looks like this.

@example
$ cat @b{~/.nb/nb_peer.keys}
foo 3.3788e45e8f64776b.0.0;
bar 7.b49ad9bfb68a97b8.fab67908064b5cb3.0;
@b{buddy 3.be5d8bc4465d3aa7.bd6107c786f72c15.0;}
@end example

@section Peer Module Server Node

@quotation
@i{Be alert to give service.  What counts a great deal in life is what we do for others.}
--- Anonymous
@end quotation

A peer server node is alert to give service, in fact, it can even give service to alerts.
It provides a method for a peer client to send any command to a NodeBrain agent: alerts, assertions, new rule definitions, etc.
It accepts TCP/IP socket connections from clients and issues received commands in the context of the server node.  The @code{server} file in the tutorial/Peer directory looks like this.

@example
#!/usr/local/bin/nb -d
# File: tutorial/Peer/server
-rm server.log
set out=".",log="server.log";
@b{declare buddy identity owner;}
@b{define myServer node peer.server("buddy@@./socket");}         # Unix domain
#define myServer node peer.server("buddy@@127.0.0.1:12345");  # local
#define myServer node peer.server("buddy@@0.0.0.0:12345");    # remote
myServer. define r1 on(a=1 and b=2);
@end example

We declare an identity @code{buddy} that we rank as @code{owner}. This is all the interpreter knows about @code{buddy}.  We use this same name, @code{buddy}, in the specification of the peer server node.  The peer node module requires that a key exist in the key store for this identity, which is why we created it in the previous section.

Let's start up our peer server.  

@example
$ ./server
2008/06/11 10:27:58 NB000I Argument [1] -d
2008/06/11 10:27:58 NB000I Argument [2] ./server
> #!/usr/local/bin/nb -d
> # File: tutorial/Peer/server
> -rm server.log
[20642] Started: -rm server.log
[20642] Exit(0)
> setout=".",log="server.log";
2008/06/11 10:27:58 NB000I NodeBrain nb will log to server.log
> declare buddy identity owner;
> @b{define myServer node peer.server("buddy@@./socket");}         # Unix domain
2008/06/11 10:27:58 NB000I Peer keys loaded.
> #define myServer node peer.server("buddy@@127.0.0.1:12345"); # local
> #define myServer node peer.server("buddy@@0.0.0.0:12345");   # remote
> myServer. define r1 on(a=1 and b=2);
2008/06/11 10:27:58 NB000I Source file "./server" included. size=493
2008/06/11 10:27:58 NB000I NodeBrain nb[20641,19542]daemonizing
$
@end example

We are using a Unix domain socket in this tutorial because we don't need to communicate with remote clients.
To experiment with serving remote clients, you can comment out the active myServernode and uncomment the remote myServer node.
But first you should experiment with the client in the next section

@section Peer Module Client Node

@quotation
@i{He who is always his own counselor will often have a fool for his client.}
--- Hunter
@end quotation

The peer module enables NodeBrain to play the part of both server and client.  This is not foolish because we are talking about different instances of NodeBrain, different processes ("skulls"), playing the roles of client and server.

The @file{client} file in the tutorial/Peer directory looks like this.

@example
#!/usr/local/bin/nb
# File: tutorial/Peer/client
@b{declare buddy identity;}
@b{define myClient node peer.client("buddy@@./socket");}         # Unix domain
#define myClient node peer.client("buddy@@localhost:12345"); # local
#define myClient node peer.client("buddy@@myhost.mydomain:12345"); # remote
@b{myClient:assert a=1,b=2;}
@b{myClient:stop;}
@end example

Notice we declare the identity @code{buddy} and specify the client just like we specified the server in the previous section.  Here there is no requirement to give @code{buddy} local permissions.  

Because we are going to run this client on the same machine as our server, and under the same user account, the client and server will use the same key store.
To run the client from a different account or machine, we would have to copy the @code{buddy} key from the server's key store to the client's key store.
We could also configure different private keys for servers and clients and copy their public keys to the key stores of their peers.  That approach provides better security, but we're more interested in quick success in this tutorial, so we'll stick with shared secret keys.

Now we can run our client and see what happens.

@example
$ ./client
2008/06/11 10:28:00 NB000I Argument [1] ./client
> #!/usr/local/bin/nb
> # File: tutorial/Peer/client
> declare buddy identity;
> @b{define myClient node peer.client("buddy@@./socket");}         # Unix domain
> #define myClient node peer.client("buddy@@localhost:12345"); # local
> #define myClient node peer.client("buddy@@myhost.mydomain:12345"); # remote
> @b{myClient:assert a=1,b=2;}
2008/06/11 10:28:00 NB000I Peer keys loaded.
2008/06/11 10:28:00 NB000I Peer b0000=buddy@@./socket
2008/06/11 10:28:00 NB000I @b{Rule myServer.r1 fired}
> @b{myClient:stop;}
2008/06/11 10:28:00 NB000I Peer b0000=buddy@@./socket
2008/06/11 10:28:00 NB000I Source file "./client" included. size=450
2008/06/11 10:28:00 NB000I NodeBrain nb[20644] terminating- exit code=0
$
@end example

The command @code{myClient:assert a=1,b=2} sends the command @code{assert a=1,b=2} to the server specified as @code{buddy@@./socket}.  Notice the message @code{Rule myServer.r1 fired}.
There is no @code{myServer.r1} defined in the client.  This is what happened at the server.  When a peer client issues a command to a peer server, the server lets the client listen in as it reacts to the command.  We can look at it from the server's point of view by displaying the agent log, in this case called @file{server.log}.

@example
$ @b{cat server.log}
  
N o d e B r a i n   0.7.0(Dunce) 2008/05/24
  
Compiled Jun 10 2008 15:30:28s390x-ibm-linux-gnu
  
Copyright (C) 1998-2008 The Boeing Company
GNU General Public License
----------------------------------------------------------------
  
nb -d ./server

Date       Time     Message
---------- ----------------------------------------------------
2008/06/11 10:27:58 NB000I NodeBrain nb[20643:1] myuser@@myhost
2008/06/11 10:27:58 NB000I Agent log is server.log
2008/06/11 10:27:58 NM000I peer.server myServer: @dots{}
@dots{} Listening for NBP connections as buddy@@./socket
2008/06/11 10:28:00 NM000I peer.server myServer: buddy@@./socket
> myServer. @b{assert a=1,b=2;}
2008/06/11 10:28:00 NB000I @b{RulemyServer.r1 fired}
2008/06/11 10:28:00 NM000I peer.server myServer: buddy@@./socket
> myServer. @b{stop;}
2008/06/11 10:28:00 NB000I NodeBrain nb[20643] terminating - exit code=0
$
@end example

At 10:27:58 our server started listening for connections. At 10:28 we received a connection and issued the command @code{assert a=1,b=2} in the @code{myServer} context.  This triggered rule @file{myServer.r1} which has no action.  In previous tutorials you've learned enough to modify the rules in server to provide an action and try it again.

Notice our client sends a stop command to the server, which stops it because we've given the client full owner permissions.  This means we have to restart the server each time we run the client.  Only in a tutorial would we do something this silly.

@section Interactive Peer Module Client

If you want to experiment further with the peer module, start the server again and try the @file{iclient} file instead of @code{client}.

@example
$ ./server
$ ./iclient
@end example

The iclient script looks like this.

@example
#!/usr/local/bin/nb -`myClient:
# File: iclient
declare buddy identity;
define myClient node peer.client("buddy@@./socket");         # Unix domain
@end example

The strange looking she-bang line has an argument that supplies an interactive command prefix and enables an option to automatically go into interactive mode after processing all command arguments.  This causes your prompt to look like this.

@example
myClient:> 
@end example

Any command you enter is now prefixed by the value @code{myClient:}, causing all your commands to be directed to your peer client node, which sends them to your peer server.
Enter the highlighted text when prompted to get the same results as shown below.

@example
$ ./iclient
2008/06/11 16:48:39 NB000I Argument [1] -'myClient:
> #!/usr/local/bin/nb -'myClient:
> # File: tutorial/Peer/iclient
> declare buddy identity;
> define myClient node peer.client("buddy@@./socket");         # Unix domain
2008/06/11 16:48:39 NB000I Source file "./iclient" included. size=209
2008/06/11 16:48:39 NB000I Reading from standard input.
---------- --------
myClient:> @b{show r1}
2008/06/11 16:48:45 NB000I Peer keys loaded.
2008/06/11 16:48:45 NB000I Peer b0000=buddy@@./socket
> myServer. show r1
r1 = ! == on((a=1)& (b=2));
myClient:> @b{assert a=1,b=2;}
2008/06/11 16:49:10 NB000I Peer b0000=buddy@@./socket
> myServer. assert a=1,b=2;
2008/06/11 16:49:10 NB000I Rule myServer.r1 fired
myClient:> @b{'foo.}
foo.> @b{'}
> @b{quit}
2008/06/11 16:49:15 NB000I NodeBrain nb[23715] terminating - exit code=0
$
@end example

This example illustrates how a single quote at the beginning of an interactive command can be used to change the command prefix.

The little tricks we illustrated in this section are features of the interpreter, not the peer module, but when combined with the peer module make it a bit easier to use NodeBrain as a primitive interactive client to a NodeBrain agent.

@node Webster
@chapter Webster Node
@cindex webster node
@cindex node, webster

@quotation
@i{The world is governed more by appearance than realities, so that it is fully as necessary to seem to know something as to know it.}
--- Daniel Webster (1782 - 1852)
@end quotation

The Webster module enables NodeBrain to pretend to be a web server.  Not with the goal of providing a web server for web applications in general, but to support little web tools associated with NodeBrain applications.

Although Webster supports x509 certificate authentication, let's skip over all that fun stuff and get it running quickly with no security. If we don't secure it with password or certificate authentication, Webster doesn't let us do anything other than display web pages, so other than exposing a port that could be vulnerable to buffer overflow errors if we have bugs, there is no risk in running it without security.

For this tutorial our files are in the tutorial/Webster sub-directory of the distribution directory.  The server script @file{webster1} looks like this.

@example
#!/usr/local/bin/nb -d
# File: tutorial/Webster/webster1
-rm webster.log
set out=".",log="webster.log";
@b{define webster node webster("default@@0.0.0.0:62443");}
@b{webster. define Protocol     cell "HTTP";}# Default is "HTTPS"
@b{webster. define Authenticate cell "no";}  # Default is "yes"
@b{webster. define DocumentRoot cell "web";} # Default is "web"
$
@end example

A Webster server is specified as @code{@i{identity}@@@i{interface}:@i{port}}.
We are using the "default" identity, all interfaces "0.0.0.0", and port 62443.  The "443" reminds us that we'd prefer to use HTTPS in a real application.  Change the port number if 62443 is used on your system.

If there are no errors in the log file, you can leave your server running and connect with your web browser using the following URL.
@example
@b{http://@i{hostname}:62443}
@end example

This tutorial continues on the page displayed by your browser.  


@node GNU Free Documentation License
@unnumbered GNU Free Documentation License
@include fdl.texi

@node Index
@unnumbered Index
@printindex cp

@bye
